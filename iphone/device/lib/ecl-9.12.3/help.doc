*
(FUNCTION "Function in COMMON-LISP package:
Syntax: (&REST NUMBERS)

Returns the product of the args.  With no args, returns 1.
" VARIABLE "Variable in COMMON-LISP package:
The value of the last top-level form.
")
SI:*BREAK-ENABLE*
(VARIABLE "ECL specific.
When an error is signaled, control enters a break loop only if the value of
this variable is non-NIL.  The initial value is T, but ECL automatically
rebinds this variable to NIL when control enters a break loop.")
*DEBUG-IO*
(VARIABLE "Variable in COMMON-LISP package:
The stream used by the ECL debugger.  The initial value is a synonym stream to
*TERMINAL-IO*.
")
CLOS::*DEFAULT-METHOD-CACHE-SIZE*
(VARIABLE "Size of hash tables for methods")
*DEFAULT-PATHNAME-DEFAULTS*
(VARIABLE "Variable in COMMON-LISP package:
The default pathname used by some pathname-handling functions such as ENOUGH-
NAMESTRING.
")
*ERROR-OUTPUT*
(VARIABLE "Variable in COMMON-LISP package:
The output stream to which error messages are output.  The initial value is an
synonym stream to *TERMINAL-IO*.
")
*FEATURES*
(VARIABLE "Variable in COMMON-LISP package:
List of symbols that name features of the current version of ECL.  These
features are used in connection with the read macros #+ and #-.  When the
reader encounters
	#+ feature-spec form
it reads FORM in the usual manner if FEATURE-SPEC is satisfied.  Otherwise,
the reader just skips FORM.
	#- feature-spec form
is equivalent to
	#- (not feature-spec) form
A feature-spec may be a symbol, in which case the spec is satisfied iff the
symbol is an element of *FEATURES*.  Or else, a feature-spec must be one of
the following forms.
	(and {feature-spec}*)
		Satisfied iff all FEATURE-SPECs are satisfied
	(or {feature-spec}*)
		Satisfied iff at least one of FEATURE-SPECs is satisfied
	(not feature-spec)
		Satisfied iff FEATURE-SPEC is not satisfied
")
SI:*HELP-MESSAGE*
(VARIABLE "Prints a help message about command line arguments of ECL")
SI:*IGNORE-EOF-ON-TERMINAL-IO*
(VARIABLE "Variable in SI package:
ECL specific.
If the value of this variable is non-NIL, ECL ignores the EOF-character
(usually ^D) on the terminal.  The initial value is NIL.
")
SI:*INDENT-FORMATTED-OUTPUT*
(VARIABLE "Variable in SI package:
ECL specific.
The FORMAT directive ~~% indents the next line, if the value of this variable
is non-NIL.  If NIL, ~~% simply does Newline.
")
SI::*INTERRUPT-ENABLE*
(VARIABLE "Variable in SI package:
ECL specific.
If the value of SI::*INTERRUPT-ENABLE* is non-NIL, ECL signals an error on the
terminal interrupt (this is the default case).  If it is NIL, ECL ignores the
interrupt and assigns T to SI::*INTERRUPT-ENABLE*.
")
SI:*LISP-INIT-FILE-LIST*
(VARIABLE "List of files automatically loaded when ECL is invoked.")
*LOAD-VERBOSE*
(VARIABLE "Variable in COMMON-LISP package:
The default value for the :VERBOSE parameter of LOAD.
It initial value is T.
")
SI::*LOOP-DESTRUCTURING-HOOKS*
(VARIABLE "If not NIL, this must be a list of two things:
a LET-like macro, and a SETQ-like macro, which perform LOOP-style destructuring.")
*MACROEXPAND-HOOK*
(VARIABLE "Variable in COMMON-LISP package:
The value of this variable must be a three-argument function object.
Each time a macro form is expanded, ECL calls that function with
	1. the macro expansion function (see MACRO-FUNCTION)
	2. the macro form to expand
	3. an environment (NIL in most case)
as three arguments, and uses the returned value as the expanded form.
The initial value of this variable is the function FUNCALL.
")
SI:*MAKE-CONSTANT
#'"Function in SI package:
Syntax: (SYMBOL VALUE)

ECL specific.
Declares that the global variable named by SYMBOL is a constant with VALUE as
its constant value.
"
SI:*MAKE-SPECIAL
#'"Function in SI package:
Syntax: SYMBOL

ECL specific.
Declares the variable named by NAME as a special variable.
"
SI:*MODULE-PROVIDER-FUNCTIONS*
(VARIABLE "See function documentation for REQUIRE")
*MODULES*
(VARIABLE "This is a list of module names that have been loaded into Lisp so far.
It is used by PROVIDE and REQUIRE.")
*PACKAGE*
(VARIABLE "Variable in COMMON-LISP package:
The current package.  The initial value is the USER package.
")
*PRINT-ARRAY*
(VARIABLE "Variable in COMMON-LISP package:
Specifies whether ECL should print elements when it prints arrays other than
strings.  ECL uses the following abbreviation notations.
	#<bit-vector n>		for bit-vectors
	#<vector n>		for vectors other than strings and bit-vectors
	#<array n>		for arrays other than vectors
where N is a number that identifies the array.
")
*PRINT-BASE*
(VARIABLE "Variable in COMMON-LISP package:
The radix used to print integers and ratios.  The value must be an integer
from 2 to 36, inclusive.  The initial value is 10.
")
*PRINT-CASE*
(VARIABLE "Variable in COMMON-LISP package:
Specifies how to print ordinary symbols.  Possible values are:
	:UPCASE		in upper case
	:DOWNCASE	in lower case
	:CAPITALIZE	the first character in upper case, the rest in lower
The initial value is :UPCASE.
")
*PRINT-CIRCLE*
(VARIABLE "Variable in COMMON-LISP package:
Specifies whether the ECL printer should take care of circular lists.
")
*PRINT-ESCAPE*
(VARIABLE "Variable in COMMON-LISP package:
Specifies whether the ECL printer should output objects in the way that they
can be reread later if possible.
")
*PRINT-GENSYM*
(VARIABLE "Variable in COMMON-LISP package:
Specifies whether the ECL printer should prefix uninterned symbols with \"#:\".
")
*PRINT-LENGTH*
(VARIABLE "Variable in COMMON-LISP package:
Specifies how many elements the ECL printer should print when it prints a
list.  ECL printer prints all elements if the value of this variable is NIL.
")
*PRINT-LEVEL*
(VARIABLE "Variable in COMMON-LISP package:
Specifies how many levels of depth the ECL printer should print when it prints
a list.  ECL printer prints all levels if the value of this variable is NIL.
")
*PRINT-PRETTY*
(VARIABLE "Variable in COMMON-LISP package:
Specifies whether the ECL printer should pretty-print.  See PPRINT for more
information about pretty-printing.
")
*PRINT-RADIX*
(VARIABLE "Variable in COMMON-LISP package:
Specifies whether the ECL printer should print the radix when it prints
integers and ratios.
")
*QUERY-IO*
(VARIABLE "Variable in COMMON-LISP package:
The query I/O stream. The initial value is a synonym stream to *TERMINAL-IO*.
")
*RANDOM-STATE*
(VARIABLE "Variable in COMMON-LISP package:
The default random-state object used by RANDOM.
")
*READ-BASE*
(VARIABLE "Variable in COMMON-LISP package:
The radix used to read numbers.  The initial value is 10.
")
*READ-DEFAULT-FLOAT-FORMAT*
(VARIABLE "Variable in COMMON-LISP package:
The default float format the ECL reader uses when reading floats.  Must be one
of the symbols SHORT-FLOAT, SINGLE-FLOAT, DOUBLE-FLOAT, and LONG-FLOAT.
")
*READ-SUPPRESS*
(VARIABLE "Variable in COMMON-LISP package:
When the value of this variable is non-NIL, the ECL reader parses input
characters without most of the ordinary processings such as interning.  Used
to skip over forms.
")
*READTABLE*
(VARIABLE "Variable in COMMON-LISP package:
The current readtable.
")
*STANDARD-INPUT*
(VARIABLE "Variable in COMMON-LISP package:
The default input stream used by the ECL reader.  The initial value is a
synonym stream to *TERMINAL-IO*.
")
*STANDARD-OUTPUT*
(VARIABLE "Variable in COMMON-LISP package:
The default output stream used by the ECL printer.  The initial value is a
synonym stream to *TERMINAL-IO*.
")
*TERMINAL-IO*
(VARIABLE "Variable in COMMON-LISP package:
The terminal I/O stream.
")
*TRACE-OUTPUT*
(VARIABLE "Variable in COMMON-LISP package:
The stream used for trace output.  The initial value is a synonym stream to
*TERMINAL-IO*.
")
+
(FUNCTION "Function in COMMON-LISP package:
Syntax: (&REST NUMBERS)

Returns the sum of the args.  With no args, returns 0.
" VARIABLE "Variable in COMMON-LISP package:
The last top-level form.
")
++
(VARIABLE "Variable in COMMON-LISP package:
The last-but-one top-level form.
")
+++
(VARIABLE "Variable in COMMON-LISP package:
The last-but-two top-level form.
")
-
(FUNCTION "Function in COMMON-LISP package:
Syntax: (NUMBER &REST MORE-NUMBERS)

Returns the first arg subtracted by the rest of args.  With one arg, returns
- NUMBER.
" VARIABLE "Variable in COMMON-LISP package:
The top-level form ECL is currently evaluating.
")
/
(FUNCTION "Function in COMMON-LISP package:
Syntax: (NUMBER &REST MORE-NUMBERS)

Returns the first arg divided by the rest of args.  With one arg, returns
1/NUMBER.
" VARIABLE "Variable in COMMON-LISP package:
The list of all values of the last top-level form.
")
//
(VARIABLE "Variable in COMMON-LISP package:
The list of all values of the last-but-one top-level form.
")
///
(VARIABLE "Variable in COMMON-LISP package:
The list of all values of the last-but-two top-level form.
")
/=
#'"Function in COMMON-LISP package:
Syntax: (NUMBER &REST MORE-NUMBERS)

Returns T if no two of the args are numerically equal; NIL otherwise.
"
1+
#'"Function in COMMON-LISP package:
Syntax: (NUMBER)

Returns NUMBER plus one.
"
1-
#'"Function in COMMON-LISP package:
Syntax: (NUMBER)

Returns NUMBER minus one.
"
<
#'"Function in COMMON-LISP package:
Syntax: (NUMBER &REST MORE-NUMBERS)

Returns T if the args are in increasing order; NIL otherwise.
"
<=
#'"Function in COMMON-LISP package:
Syntax: (NUMBER &REST MORE-NUMBERS)

Returns T if the args are in non-decreasing order; NIL otherwise.
"
=
#'"Function in COMMON-LISP package:
Syntax: (NUMBER &REST MORE-NUMBERS)

Returns T if all args are numerically equal; NIL otherwise.
"
>
#'"Function in COMMON-LISP package:
Syntax: (NUMBER &REST MORE-NUMBERS)

Returns T if the args are in decreasing order; NIL otherwise.
"
>=
#'"Function in COMMON-LISP package:
Syntax: (NUMBER &REST MORE-NUMBERS)

Returns T if the args are in non-increasing order; NIL otherwise.
"
ABS
#'"Function in COMMON-LISP package:
Syntax: (NUMBER)

Returns the absolute value of NUMBER.
"
ACONS
#'"Function in COMMON-LISP package:
Syntax: (KEY DATUM ALIST)

Equivalent to (CONS (CONS KEY DATUM) ALIST).
"
ACOS
#'"Args: (number)
Returns the arc cosine of NUMBER."
ACOSH
#'"Args: (number)
Returns the hyperbolic arc cosine of NUMBER."
ADJOIN
#'"Function in COMMON-LISP package:
Syntax: (ITEM LIST &KEY (KEY '#'IDENTITY) (TEST '#'EQL) TEST-NOT)

Returns cons of ITEM and LIST unless ITEM is already an element of LIST.
Otherwise, returns LIST.
"
ADJUST-ARRAY
#'"Args: (array dimensions
       &key (element-type (array-element-type array))
            initial-element (initial-contents nil) (fill-pointer nil)
            (displaced-to nil) (displaced-index-offset 0))
Adjusts the dimensions of ARRAY to the given DIMENSIONS.  ARRAY must be an
adjustable array."
ADJUSTABLE-ARRAY-P
#'"Function in COMMON-LISP package:
Syntax: (ARRAY)

Returns T if ARRAY is adjustable; NIL otherwise.
"
SI::ALLOCATE-GFUN
#'"Function in SI package:
Syntax: (NAME ARITY HASH-TABLE)

ECL/CLOS specific.
Allocates a gfun object in which NAME is the generic function name, ARITY
is the number of arguments and HASH-TABLE is the hashtable for cashing
methods.
"
ALLOCATE-INSTANCE
#'"Function in COMMON-LISP package:
Syntax: (CLASS LENGTH)

ECL/CLOS specific.
Allocates an istance of CLASS with LENGTH slots.
"
ALPHA-CHAR-P
#'"Function in COMMON-LISP package:
Syntax: (CHAR)

Returns T if CHAR is alphabetic; NIL otherwise.
"
ALPHANUMERICP
#'"Function in COMMON-LISP package:
Syntax: (CHAR)

Returns T if CHAR is either numeric or alphabetic; NIL otherwise.
"
AND
#'"Macro in COMMON-LISP package:
Syntax: (and {form}*)

Evaluates FORMs in order.  If any FORM evaluates to NIL, returns
immediately with the value NIL.  Otherwise, returns all values of the
last FORM.
"
APPEND
#'"Function in COMMON-LISP package:
Syntax: (&REST LISTS)

Constructs and returns a new list by concatenating the args.
"
APPLY
#'"Function in COMMON-LISP package:
Syntax: (FUNCTION ARG &REST MORE-ARGS)

Calls FUNCTION with all ARGs except the last and all elements of the last ARG
as the arguments to FUNCTION.  Returns all values that FUNCTION returns.
"
SI::APPLYHOOK
#'"Function in SI package:
Syntax: (FUNCTION LIST EVALHOOKFN APPLYHOOKFN &OPTIONAL (ENV NIL))

Calls FUNCTION with all elements of LIST as the arguments and with *EVALHOOK*
and *APPLYHOOK* bound to EVALHOOKFN and APPLYHOOKFN respectively.  Returns all
values that FUNCTION returns.
"
APROPOS
#'"Args: (string &optional (package nil))
Prints those symbols whose print-names contain STRING as substring.  If
PACKAGE is non-NIL, then only the specified PACKAGE is searched."
APROPOS-LIST
#'"Args: (string &optional (package nil))
Returns a list of all symbols whose print-names contain STRING as substring.
If PACKAGE is non-NIL, then only the specified PACKAGE is searched."
AREF
#'"Function in COMMON-LISP package:
Syntax: (ARRAY &REST INDEXES)

Returns the element of ARRAY specified by INDEXES.
"
SI:ARGC
#'"Function in SI package:
Syntax: NIL

ECL specific.
Returns the number of arguments given in the command line that invoked ECL.
"
SI:ARGV
#'"Function in SI package:
Syntax: (N)

ECL specific.
Returns the N-th argument given in the command line that invoked ECL.
"
ARRAY
(TYPE "
An array is a compound object whose elements are referenced by indexing.  One-
dimensional arrays are called vectors.  Other arrays are notated as
	#?a( ... )	or	#?A( ... )
where '?' is actually the rank of the array.
Arrays may be displaced to another array, may have a fill-pointer, or may be
adjustable.  Other arrays are called simple-arrays.  Only simple-arrays can be
input in the above format.")
ARRAY-DIMENSION
#'"Function in COMMON-LISP package:
Syntax: (ARRAY N)

Returns the length of the N-th dimension of ARRAY.
"
ARRAY-DIMENSION-LIMIT
(VARIABLE "Constant in COMMON-LISP package:
The upper bound of the length of an array dimension.
")
ARRAY-DIMENSIONS
#'"Args: (array)
Returns a list whose N-th element is the length of the N-th dimension of ARRAY."
ARRAY-ELEMENT-TYPE
#'"Function in COMMON-LISP package:
Syntax: (ARRAY)

Returns the element type ARRAY.
"
ARRAY-HAS-FILL-POINTER-P
#'"Function in COMMON-LISP package:
Syntax: (ARRAY)

Returns T if ARRAY has a fill-pointer; NIL otherwise.
"
ARRAY-IN-BOUNDS-P
#'"Args: (array &rest indexes)
Returns T if INDEXes are valid indexes of ARRAY; NIL otherwise.  The number of
INDEXes must be equal to the rank of ARRAY."
ARRAY-RANK
#'"Function in COMMON-LISP package:
Syntax: (ARRAY)

Returns the rank of ARRAY.
"
ARRAY-RANK-LIMIT
(VARIABLE "Constant in COMMON-LISP package:
The upper bound of the rank of an array.
")
ARRAY-ROW-MAJOR-INDEX
#'"Args: (array &rest indexes)
Returns the non-negative integer that represents the location of the element
of ARRAY specified by INDEXes, assuming all elements of ARRAY are aligned in
row-major order."
ARRAY-TOTAL-SIZE
#'"Function in COMMON-LISP package:
Syntax: (ARRAY)

Returns the total number of elements of ARRAY.
"
ARRAY-TOTAL-SIZE-LIMIT
(VARIABLE "Constant in COMMON-LISP package:
The upper bound of the total number of elements of an array.
")
ARRAYP
#'"Function in COMMON-LISP package:
Syntax: (X)

Returns T if X is an array; NIL otherwise.
"
ASH
#'"Function in COMMON-LISP package:
Syntax: (INTEGER COUNT)

Returns the integer obtained by shifting the bits that represent INTEGER as
specified by COUNT.  Shifts left in COUNT bits if COUNT is positive.  Shifts
right in -COUNT bits if COUNT is negative.
"
ASIN
#'"Args: (number)
Returns the arc sine of NUMBER."
ASINH
#'"Args: (number)
Returns the hyperbolic arc sine of NUMBER."
ASSERT
#'"Args: (assert form [({place}*) [string {arg}*]])
Evaluates FORM and signals a continuable error if the value is NIL.  Before
continuing, receives new values of PLACEs from user.  Repeats this process
until FORM returns a non-NIL value.  Returns NIL.  STRING is the format string
for the error message and ARGs are arguments to the format string."
ASSOC
#'"Function in COMMON-LISP package:
Syntax: (ITEM ALIST &KEY (TEST '#'EQL) TEST-NOT (KEY '#'IDENTITY))

Returns the first pair in ALIST whose car is equal (in the sense of TEST) to
ITEM.  Returns NIL if no such pair exists.
The function KEY is applied to extract the key for comparison.
"
ASSOC-IF
#'"Returns the first pair in ALIST whose car satisfies TEST.  Returns NIL if no
such pair exists."
ASSOC-IF-NOT
#'"Returns the first pair in ALIST whose car does not satisfy TEST.  Returns NIL
if no such pair exists."
ATAN
#'"Function in COMMON-LISP package:
Syntax: (X &OPTIONAL (Y 1))

Returns the arc tangent of X/Y.
"
ATANH
#'"Args: (number)
Returns the hyperbolic arc tangent of NUMBER."
ATOM
(FUNCTION "Function in COMMON-LISP package:
Syntax: (X)

Returns T if X is not a cons; NIL otherwise.
" TYPE "An ATOM is an object that is not a CONS.")
BASE-STRING
(TYPE "A string which is made of BASE-CHAR.")
SI:BDS-VAL
#'"Function in SI package:
Syntax: (N)

ECL specific.
Returns the value of the N-th entity in the bind stack.
"
SI:BDS-VAR
#'"Function in SI package:
Syntax: (N)

ECL specific.
Returns the symbol of the N-th entity in the bind stack.
"
BIGNUM
(TYPE "
A bignum is an integer that is not a fixnum.")
BIT
(FUNCTION "Args: (bit-array &rest indexes)
Returns the bit of BIT-ARRAY specified by INDEXes." TYPE "A BIT is either integer 0 or 1.")
BIT-AND
#'"Args: (bit-array1 bit-array2 &optional (result nil))
Returns the element-wise AND of BIT-ARRAY1 and BIT-ARRAY2.  Puts the results
into a new bit-array if RESULT is NIL, into BIT-ARRAY1 if RESULT is T, or into
RESULT if RESULT is a bit-array."
BIT-ANDC1
#'"Args: (bit-array1 bit-array2 &optional (result nil))
Returns the element-wise AND of {the element-wise NOT of BIT-ARRAY1} and BIT-
ARRAY2.  Puts the results into a new bit-array if RESULT is NIL, into BIT-
ARRAY1 if RESULT is T, or into RESULT if RESULT is a bit-array."
BIT-ANDC2
#'"Args: (bit-array1 bit-array2 &optional (result nil))
Returns the element-wise AND of BIT-ARRAY1 and {the element-wise NOT of BIT-
ARRAY2}.  Puts the results into a new bit-array if RESULT is NIL, into BIT-
ARRAY1 if RESULT is T, or into RESULT if RESULT is a bit-array."
BIT-EQV
#'"Args: (bit-array1 bit-array2 &optional (result nil))
Returns the element-wise EQUIVALENCE of BIT-ARRAY1 and BIT-ARRAY2.  Puts the
results into a new bit-array if RESULT is NIL, into BIT-ARRAY1 if RESULT is T,
or into RESULT if RESULT is a bit-array."
BIT-IOR
#'"Args: (bit-array1 bit-array2 &optional (result nil))
Returns the element-wise INCLUSIVE OR of BIT-ARRAY1 and BIT-ARRAY2.  Puts the
results into a new bit-array if RESULT is NIL, into BIT-ARRAY1 if RESULT is T,
or into RESULT if RESULT is a bit-array."
BIT-NAND
#'"Args: (bit-array1 bit-array2 &optional (result nil))
Returns the element-wise NOT of {the element-wise AND of BIT-ARRAY1 and BIT-
ARRAY2}.  Puts the results into a new bit-array if RESULT is NIL, into BIT-
ARRAY1 if RESULT is T, or into RESULT if RESULT is a bit-array."
BIT-NOR
#'"Args: (bit-array1 bit-array2 &optional (result nil))
Returns the element-wise NOT of {the element-wise INCLUSIVE OR of BIT-ARRAY1
and BIT-ARRAY2}.  Puts the results into a new bit-array if RESULT is NIL, into
BIT-ARRAY1 if RESULT is T, or into RESULT if RESULT is a bit-array."
BIT-NOT
#'"Args: (bit-array &optional (result nil))
Returns the element-wise NOT of BIT-ARRAY.  Puts the results into a new bit-
array if RESULT is NIL, into BIT-ARRAY if RESULT is T, or into RESULT if
RESULT is a bit-array."
BIT-ORC1
#'"Args: (bit-array1 bit-array2 &optional (result nil))
Returns the element-wise INCLUSIVE OR of {the element-wise NOT of BIT-ARRAY1}
and BIT-ARRAY2.  Puts the results into a new bit-array if RESULT is NIL, into
BIT-ARRAY1 if RESULT is T, or into RESULT if RESULT is a bit-array."
BIT-ORC2
#'"Args: (bit-array1 bit-array2 &optional (result nil))
Returns the element-wise INCLUSIVE OR of BIT-ARRAY1 and {the element-wise NOT
of BIT-ARRAY2}.  Puts the results into a new bit-array if RESULT is NIL, into
BIT-ARRAY1 if RESULT is T, or into RESULT if RESULT is a bit-array."
BIT-VECTOR
(TYPE "A bit-vector is a vector of bits.  A bit-vector is notated by '#*' followed
by its elements (0 or 1).  Bit-vectors may be displaced to another array, may
have a fill-pointer, or may be adjustable.  Other bit-vectors are called
simple-bit-vectors.  Only simple-bit-vectors can be input in the above format
using '#*'.")
BIT-VECTOR-P
#'"Function in COMMON-LISP package:
Syntax: (X)

Returns T if X is a bit-vector; NIL otherwise.
"
BIT-XOR
#'"Args: (bit-array1 bit-array2 &optional (result nil))
Returns the element-wise EXCLUSIVE OR of BIT-ARRAY1 and BIT-ARRAY2.  Puts the
results into a new bit-array if RESULT is NIL, into BIT-ARRAY1 if RESULT is T,
or into RESULT if RESULT is a bit-array."
BLOCK
#'"Special Form in COMMON-LISP package:
Syntax: (block name {form}*)

Establishes a block named by NAME, evaluates FORMs in order, and returns all
values of the last FORM.  Returns NIL if no FORMs are given.
The scope of the established block is the body (i.e. the FORMs) of the BLOCK
form.  If (return-from name value-form) is evaluated within the scope, the
execution of the BLOCK form terminates immediately and all values of
VALUE-FORM will be returned as the values of the terminated BLOCK form.
"
BOOLE
#'"Function in COMMON-LISP package:
Syntax: (OP INTEGER1 INTEGER2)

Returns the integer produced by the logical operation specified by OP on the
two integers.  OP must be the value of one of the following constants.
	BOOLE-CLR	BOOLE-C1	BOOLE-XOR	BOOLE-ANDC1
	BOOLE-SET	BOOLE-C2	BOOLE-EQV	BOOLE-ANDC2
	BOOLE-1		BOOLE-AND	BOOLE-NAND	BOOLE-ORC1
	BOOLE-2		BOOLE-IOR	BOOLE-NOR	BOOLE-ORC2
Each logical operation on integers produces an integer represented by the bit
sequence obtained by a bit-wise logical operation on the bit sequences that
represent the integers.  Two's-complement representation is assumed to obtain
the bit sequence that represents an integer.  For example,
	 2:  ...010
	 1:  ...001
	 0:  ...000
	-1:  ...111
	-2:  ...110
where each '...' represents either an infinite sequence of 0's (for non-
negative integers) or an infinite sequence of 1's (for negative integers).
"
BOOLE-1
(VARIABLE "Constant in COMMON-LISP package:
Makes BOOLE return INTEGER1.
")
BOOLE-2
(VARIABLE "Constant in COMMON-LISP package:
Makes BOOLE return INTEGER2.
")
BOOLE-AND
(VARIABLE "Constant in COMMON-LISP package:
Makes BOOLE return the AND of INTEGER1 and INTEGER2.
")
BOOLE-ANDC1
(VARIABLE "Constant in COMMON-LISP package:
Makes BOOLE return the AND of {the NOT of INTEGER1} and INTEGER2.
")
BOOLE-ANDC2
(VARIABLE "Constant in COMMON-LISP package:
Makes BOOLE return the AND of INTEGER1 and {the NOT of INTEGER2}.
")
BOOLE-C1
(VARIABLE "Constant in COMMON-LISP package:
Makes BOOLE return the NOT of INTEGER1.
")
BOOLE-C2
(VARIABLE "Constant in COMMON-LISP package:
Makes BOOLE return the NOT of INTEGER2.
")
BOOLE-CLR
(VARIABLE "Constant in COMMON-LISP package:
Makes BOOLE return 0.
")
BOOLE-EQV
(VARIABLE "Constant in COMMON-LISP package:
Makes BOOLE return the EQUIVALENCE of INTEGER1 and INTEGER2.
")
BOOLE-IOR
(VARIABLE "Constant in COMMON-LISP package:
Makes BOOLE return the INCLUSIVE OR of INTEGER1 and INTEGER2.
")
BOOLE-NAND
(VARIABLE "Constant in COMMON-LISP package:
Makes BOOLE return the NOT of {the AND of INTEGER1 and INTEGER2}.
")
BOOLE-NOR
(VARIABLE "Constant in COMMON-LISP package:
Makes BOOLE return the NOT of {the INCLUSIVE OR of INTEGER1 and INTEGER2}.
")
BOOLE-ORC1
(VARIABLE "Constant in COMMON-LISP package:
Makes BOOLE return the INCLUSIVE OR of {the NOT of INTEGER1} and INTEGER2.
")
BOOLE-ORC2
(VARIABLE "Constant in COMMON-LISP package:
Makes BOOLE return the INCLUSIVE OR of INTEGER1 and {the NOT of INTEGER2}.
")
BOOLE-SET
(VARIABLE "Constant in COMMON-LISP package:
Makes BOOLE return -1.
")
BOOLE-XOR
(VARIABLE "Constant in COMMON-LISP package:
Makes BOOLE return the EXCLUSIVE OR of INTEGER1 and INTEGER2.
")
BOOLEAN
(TYPE "A BOOLEAN is an object which is either NIL or T.")
BOTH-CASE-P
#'"Function in COMMON-LISP package:
Syntax: (CHAR)

Returns T if CHAR is an alphabetic character; NIL otherwise.  Equivalent to
ALPHA-CHAR-P.
"
BOUNDP
#'"Function in COMMON-LISP package:
Syntax: (SYMBOL)

Returns T if the global variable named SYMBOL has a value; NIL otherwise.
"
BREAK
#'"Enters a break loop.  The execution of the program can be resumed by typing
:CONTINUE at the break loop.  Type :HELP to see the break-loop commands list.
If FORMAT-STRING is non-NIL, it is used as the format string to be output to
*ERROR-OUTPUT* before entering the break loop.  ARGs are arguments to the
format string."
BUTLAST
#'"Function in COMMON-LISP package:
Syntax: (LIST &OPTIONAL (N 1))

Returns a copy of LIST with the last N elements removed.
"
SI::BY
#'"Function in SI package:
Syntax: NIL

ECL specific.
Exits from ECL.  Equivalent to BYE.
"
SI::BYE
#'"Function in SI package:
Syntax: NIL

ECL specific.
Exits from ECL.  Equivalent to BY.
"
BYTE
#'"Args: (size position)
Returns a byte specifier of integers.  The value specifies the SIZE-bits byte
starting the least-significant-bit but POSITION bits of integers.  In ECL, a
byte specifier is represented by a dotted pair (SIZE . POSITION)."
BYTE-POSITION
#'"Args: (byte)
Returns the position part (in ECL, the cdr part) of the byte specifier BYTE."
BYTE-SIZE
#'"Args: (byte)
Returns the size part (in ECL, the car part) of the byte specifier BYTE."
CAAAAR
#'"Function in COMMON-LISP package:
Syntax: (X)

Equivalent to (CAR (CAR (CAR (CAR X)))).
"
CAAADR
#'"Function in COMMON-LISP package:
Syntax: (X)

Equivalent to (CAR (CAR (CAR (CDR X)))).
"
CAAAR
#'"Function in COMMON-LISP package:
Syntax: (X)

Equivalent to (CAR (CAR (CAR X))).
"
CAADAR
#'"Function in COMMON-LISP package:
Syntax: (X)

Equivalent to (CAR (CAR (CDR (CAR X)))).
"
CAADDR
#'"Function in COMMON-LISP package:
Syntax: (X)

Equivalent to (CAR (CAR (CDR (CDR X)))).
"
CAADR
#'"Function in COMMON-LISP package:
Syntax: (X)

Equivalent to (CAR (CAR (CDR X))).
"
CAAR
#'"Function in COMMON-LISP package:
Syntax: (X)

Equivalent to (CAR (CAR X)).
"
CADAAR
#'"Function in COMMON-LISP package:
Syntax: (X)

Equivalent to (CAR (CDR (CAR (CAR X)))).
"
CADADR
#'"Function in COMMON-LISP package:
Syntax: (X)

Equivalent to (CAR (CDR (CAR (CDR X)))).
"
CADAR
#'"Function in COMMON-LISP package:
Syntax: (X)

Equivalent to (CAR (CDR (CAR X))).
"
CADDAR
#'"Function in COMMON-LISP package:
Syntax: (X)

Equivalent to (CAR (CDR (CDR (CAR X)))).
"
CADDDR
#'"Function in COMMON-LISP package:
Syntax: (X)

Equivalent to (CAR (CDR (CDR (CDR X)))).
"
CADDR
#'"Function in COMMON-LISP package:
Syntax: (X)

Equivalent to (CAR (CDR (CDR X))).
"
CADR
#'"Function in COMMON-LISP package:
Syntax: (X)

Equivalent to (CAR (CDR X)).
"
CALL-ARGUMENTS-LIMIT
(VARIABLE "Constant in COMMON-LISP package:
The upper bound of the number of arguments to a function.  Ignore this value
since there is no such logical upper bound in ECL.
")
CAR
#'"Function in COMMON-LISP package:
Syntax: (X)

Returns the car of X if X is a cons.  Returns NIL if X is NIL.
"
CASE
#'"Macro in COMMON-LISP package:
Syntax: (case keyform {({key | ({key}*)} {form}*)}*)

Evaluates KEYFORM and searches a KEY that is EQL to the value of KEYFORM.  If
found, then evaluates FORMs in order that follow the KEY (or the key list that
contains the KEY) and returns all values of the last FORM.  Returns NIL if no
such key is found.  The symbols T and OTHERWISE may be used at the place of a
key list to specify the default case.
"
CATCH
#'"Special Form in COMMON-LISP package:
Syntax: (catch tag-form {form}*)

Sets up a catcher whose catch tag is the value of TAG-FORM.  Then evaluates
FORMs in order and returns all values of the last FORM.  During the evaluation
of FORMs, if a THROW form is evaluated that specifies a catch tag EQ to the
value of the TAG-FORM, then the execution of the CATCH form terminates
immediately and the values specified by the THROW form are returned as the
value of the CATCH form.
"
CCASE
#'"Syntax: (ccase place {({key | ({key}*)} {form}*)}*)
Searches a KEY that is EQL to the value of PLACE.  If found, then evaluates
FORMs in order that follow the KEY (or the key list that contains the KEY) and
returns all values of the last FORM.  If no such KEY is found, signals a
continuable error.  Before continuing, receives a new value of PLACE from
user and searches a KEY again.  Repeats this process until the value of PLACE
becomes EQL to one of the KEYs."
CDAAAR
#'"Function in COMMON-LISP package:
Syntax: (X)

Equivalent to (CDR (CAR (CAR (CAR X)))).
"
CDAADR
#'"Function in COMMON-LISP package:
Syntax: (X)

Equivalent to (CDR (CAR (CAR (CDR X)))).
"
CDAAR
#'"Function in COMMON-LISP package:
Syntax: (X)

Equivalent to (CDR (CAR (CAR X))).
"
CDADAR
#'"Function in COMMON-LISP package:
Syntax: (X)

Equivalent to (CDR (CAR (CDR (CAR X)))).
"
CDADDR
#'"Function in COMMON-LISP package:
Syntax: (X)

Equivalent to (CDR (CAR (CDR (CDR X)))).
"
CDADR
#'"Function in COMMON-LISP package:
Syntax: (X)

Equivalent to (CDR (CAR (CDR X))).
"
CDAR
#'"Function in COMMON-LISP package:
Syntax: (X)

Equivalent to (CDR (CAR X)).
"
CDDAAR
#'"Function in COMMON-LISP package:
Syntax: (X)

Equivalent to (CDR (CDR (CAR (CAR X)))).
"
CDDADR
#'"Function in COMMON-LISP package:
Syntax: (X)

Equivalent to (CDR (CDR (CAR (CDR X)))).
"
CDDAR
#'"Function in COMMON-LISP package:
Syntax: (X)

Equivalent to (CDR (CDR (CAR X))).
"
CDDDAR
#'"Function in COMMON-LISP package:
Syntax: (X)

Equivalent to (CDR (CDR (CDR (CAR X)))).
"
CDDDDR
#'"Function in COMMON-LISP package:
Syntax: (X)

Equivalent to (CDR (CDR (CDR (CDR X)))).
"
CDDDR
#'"Function in COMMON-LISP package:
Syntax: (X)

Equivalent to (CDR (CDR (CDR X))).
"
CDDR
#'"Function in COMMON-LISP package:
Syntax: (X)

Equivalent to (CDR (CDR X)).
"
CDR
#'"Function in COMMON-LISP package:
Syntax: (X)

Returns the cdr of X if X is a cons.  Returns NIL if X is NIL.
"
CEILING
#'"Function in COMMON-LISP package:
Syntax: (NUMBER &OPTIONAL (DIVISOR 1))

Returns the smallest integer not less than NUMBER/DIVISOR.  Returns the value
of (- NUMBER (* first-value DIVISOR)) as the second value.
"
CERROR
#'"Function in COMMON-LISP package:
Syntax: (CONTINUE-FORMAT-STRING ERROR-FORMAT-STRING &REST ARGS)

Signals a continuable error.
"
CHAR
#'"Function in COMMON-LISP package:
Syntax: (STRING INDEX)

Returns the INDEX-th character in STRING.
"
SI::CHAR-BIT
#'"Function in SI package:
Syntax: (CHAR NAME)

Returns T if the specified bit attribute of CHAR is 'on'; NIL otherwise.
In ECL the bit-attributes handled are :control :meta :super and :hyper
"
SI::CHAR-BITS
#'"Function in SI package:
Syntax: (CHAR)

Returns the bit attributes of CHAR as an integer. In ECL it returns a value
between 0 and 16, since ECL handle 4 bit attributes.
"
SI::CHAR-BITS-LIMIT
(VARIABLE "Constant in SI package:
The upper bound of values returned by CHAR-BITS.  16 in ECL.
")
CHAR-CODE
#'"Function in COMMON-LISP package:
Syntax: (CHAR)

Returns the character code of CHAR as a fixnum.
"
CHAR-CODE-LIMIT
(VARIABLE "Constant in COMMON-LISP package:
The upper bound of values returned by CHAR-CODE.
")
SI::CHAR-CONTROL-BIT
(VARIABLE "Constant in SI package:
The bit position indicating a control character.  1 in ECL.
")
CHAR-DOWNCASE
#'"Function in COMMON-LISP package:
Syntax: (CHAR)

Returns the lower-case character corresponding to CHAR, if CHAR is upper-case.
Otherwise, returns CHAR.
"
CHAR-EQUAL
#'"Function in COMMON-LISP package:
Syntax: (CHAR &REST MORE-CHARS)

Returns T if all CHARs are the same; NIL otherwise.  Lower-case characters are
regarded the same as the corresponding upper-case characters.
"
SI::CHAR-FONT
#'"Function in SI package:
Syntax: (CHAR)

Returns the font attribute of CHAR.  Returns always 0 in ECL, since ECL
characters have no font attributes.
"
SI::CHAR-FONT-LIMIT
(VARIABLE "Constant in SI package:
The upper bound of values returned by CHAR-FONT.  1 in ECL.
")
CHAR-GREATERP
#'"Function in COMMON-LISP package:
Syntax: (CHAR &REST MORE-CHARS)

Returns T if the character codes of CHARs are in decreasing order; NIL
otherwise.  For lower-case characters, codes of corresponding upper-case
characters are used.
"
SI::CHAR-HYPER-BIT
(VARIABLE "Constant in SI package:
The bit position indicating a hyper character.  8 in ECL.
")
CHAR-INT
#'"Function in COMMON-LISP package:
Syntax: (CHAR)

Returns the font, bits, and code attributes as an integer.  Equivalent to
CHAR-CODE in ECL.
"
CHAR-LESSP
#'"Function in COMMON-LISP package:
Syntax: (CHAR &REST MORE-CHARS)

Returns T if the character codes of CHARs are in increasing order; NIL
otherwise.  For lower-case characters, codes of corresponding upper-case
characters are used.
"
SI::CHAR-META-BIT
(VARIABLE "Constant in SI package:
The bit position indicating a meta character.  2 in ECL.
")
CHAR-NAME
#'"Function in COMMON-LISP package:
Syntax: (CHAR)

Returns the 'character name' of CHAR as a string; NIL if CHAR has no character
name.  Only #\\Backspace, #\\Tab, #\\Newline (or #\\Linefeed), #\\Page,
#\\Return, and #\\Rubout have character names in ECL.
"
CHAR-NOT-EQUAL
#'"Function in COMMON-LISP package:
Syntax: (CHAR &REST MORE-CHARS)

Returns T if no two of CHARs are the same; NIL otherwise.  Lower-case
characters are regarded the same as the corresponding upper-case characters.
"
CHAR-NOT-GREATERP
#'"Function in COMMON-LISP package:
Syntax: (CHAR &REST MORE-CHARS)

Returns T if the character codes of CHARs are in non-decreasing order; NIL
otherwise.  For lower-case characters, codes of corresponding upper-case
characters are used.
"
CHAR-NOT-LESSP
#'"Function in COMMON-LISP package:
Syntax: (CHAR &REST MORE-CHARS)

Returns T if the character codes of CHARs are in non-increasing order; NIL
otherwise.  For lower-case characters, codes of corresponding upper-case
characters are used.
"
SI::CHAR-SUPER-BIT
(VARIABLE "Constant in SI package:
The bit position indicating a super character.  4 in ECL.
")
CHAR-UPCASE
#'"Function in COMMON-LISP package:
Syntax: (CHAR)

Returns the upper-case character of CHAR, if CHAR is lower-case.  Otherwise,
returns CHAR.
"
CHAR/=
#'"Function in COMMON-LISP package:
Syntax: (CHAR &REST MORE-CHARS)

Returns T if no two of CHARs are the same; NIL otherwise.
"
CHAR<
#'"Function in COMMON-LISP package:
Syntax: (CHAR &REST MORE-CHARS)

Returns T if the character codes of CHARs are in increasing order; NIL
otherwise.
"
CHAR<=
#'"Function in COMMON-LISP package:
Syntax: (CHAR &REST MORE-CHARS)

Returns T if the character codes of CHARs are in non-decreasing order; NIL
otherwise.
"
CHAR=
#'"Function in COMMON-LISP package:
Syntax: (CHAR &REST MORE-CHARS)

Returns T if all CHARs are the same; NIL otherwise.
"
CHAR>
#'"Function in COMMON-LISP package:
Syntax: (CHAR &REST MORE-CHARS)

Returns T if the character codes of CHARs are in decreasing order; NIL
otherwise.
"
CHAR>=
#'"Function in COMMON-LISP package:
Syntax: (CHAR &REST MORE-CHARS)

Returns T if the character codes of CHARs are in non-increasing order; NIL
otherwise.
"
CHARACTER
(FUNCTION "Function in COMMON-LISP package:
Syntax: (X)

Coerces X into a character if possible.  Signals an error if not possible.
" TYPE "
A character represents a character that can be handled by the computer.
Characters have font, bits, and code attributes.  Font and bits attributes
are always 0 in ECL.  Most versions of ECL uses ASCII code:
  000 - 037	#\\^@  #\\^A  #^B ... #\\Z  #\\^[  #\\^\\  #\\^]  #\\^^  #\\^_
		except #\\Tab(011)     #\\Newline(012)     #\\Page(014)
		       #\\Return(015)  #\\Backspace(031)
  040 - 057	#\\Space  #\\!  #\\\"  #\\#  #\\$  #\\%  #\\&  #\\'  #\\(  #\\)  #\\*
		#\\+  #\\,  #\\-  #\\.  #\\/
  060 - 071	#\\0  #\\1  #\\2  #\\3  #\\4  #\\5  #\\6  #\\7  #\\8  #\\9
  072 - 100	#\\:  #\\;  #\\<  #\\=  #\\>  #\\?  #\\@
  101 - 132	#\\A ... #\\Z
  133 - 140	#\\[  #\\\\  #\\]  #\\^  #\\_  #\\`
  141 - 172	#\\a ... #\\z
  173 - 177	#\\{  #\\|  #\\}  #\\~~  #\\Rubout
Some versions of ECL support additional characters to represent Japanese
character set.")
CHARACTERP
#'"Function in COMMON-LISP package:
Syntax: (X)

Returns T if X is a character; NIL otherwise.
"
SI:CHDIR
#'"Function in SI package:
Syntax: (FILESPEC &OPTIONAL (UPDATE-LISP T))

Changes the current working directory of the C library to the one specified by
FILESPEC.  FILESPEC may be a symbol, a string, or a pathname. UPDATE-LISP
determines whether the value of *DEFAULT-PATHNAME-DEFAULTS* is also to be
changed.
"
SI::CHECK-PRINT-LEVEL
#'"Automatically handle *print-level* abbreviation.  If we are too deep, then
   a # is printed to STREAM and BODY is ignored."
CHECK-TYPE
#'"Args: (check-type place typespec [string-form])
Signals a continuable error, if the value of PLACE is not of the specified
type.  Before continuing, receives a new value of PLACE from the user and
checks the type again.  Repeats this process until the value of PLACE becomes
of the specified type.  STRING-FORM, if given, is evaluated only once and the
value is used to indicate the expected type in the error message."
CIS
#'"Args: (radians)
Returns a complex number whose realpart and imagpart are the values of (COS
RADIANS) and (SIN RADIANS) respectively."
CLEAR-INPUT
#'"Function in COMMON-LISP package:
Syntax: (&OPTIONAL (STREAM *STANDARD-INPUT*))

Clears the input buffer of STREAM and returns NIL.  Contents of the buffer are
discarded.
"
CLEAR-OUTPUT
#'"Function in COMMON-LISP package:
Syntax: (&OPTIONAL (STREAM *STANDARD-OUTPUT*))

Clears the output buffer of STREAM and returns NIL.  Contents of the buffer
are discarded.
"
FFI:CLINES
#'"Special Form in FFI package:
Syntax: (clines {string}*)


The ECL compiler embeds STRINGs into the intermediate C language code.  The
interpreter ignores this form.
"
CLOSE
#'"Function in COMMON-LISP package:
Syntax: (STREAM &KEY (ABORT NIL))

Closes STREAM.  Returns NIL if STREAM is closed successfully; non-NIL
otherwise.  A non-NIL value of ABORT indicates an abnormal termination but ECL
ignores it.
"
CLRHASH
#'"Function in COMMON-LISP package:
Syntax: (HASH-TABLE)

Removes all entries of HASH-TABLE and returns HASH-TABLE.
"
CODE-CHAR
#'"Function in COMMON-LISP package:
Syntax: (CODE &OPTIONAL (BITS 0) (FONT 0))

Returns a character with the specified character code, if any.  Returns NIL
if no such character exists.  BITS and FONT specify the bits and font
attributes of the returned character but are both ignored in ECL.
"
COERCE
#'"Args: (x type)
Coerces X to an object of the specified type, if possible.  Signals an error
if not possible."
SI::COLLECT
#'"Collect ({(Name [Initial-Value] [Function])}*) {Form}*
  Collect some values somehow.  Each of the collections specifies a bunch of
  things which collected during the evaluation of the body of the form.  The
  name of the collection is used to define a local macro, a la MACROLET.
  Within the body, this macro will evaluate each of its arguments and collect
  the result, returning the current value after the collection is done.  The
  body is evaluated as a PROGN; to get the final values when you are done, just
  call the collection macro with no arguments.

  Initial-Value is the value that the collection starts out with, which
  defaults to NIL.  Function is the function which does the collection.  It is
  a function which will accept two arguments: the value to be collected and the
  current collection.  The result of the function is made the new value for the
  collection.  As a totally magical special-case, the Function may be Collect,
  which tells us to build a list in forward order; this is the default.  If an
  Initial-Value is supplied for Collect, the stuff will be rplacd'd onto the
  end.  Note that Function may be anything that can appear in the functional
  position, including macros and lambdas."
SI:COMMAND-ARGS
#'"Returns the command line arguments as list"
SI::COMMON
(TYPE "
COMMON is the type of all Common Lisp data objects.")
SI::COMMONP
#'"Function in SI package:
Syntax: (X)

Returns T if X is a Common Lisp object; NIL otherwise.
"
COMPILED-FUNCTION
(TYPE "
A compiled function is an object that is created by compiling a function.  A
compiled function is notated in either of the following formats:
	#<compiled-function s>
	#<compiled-closure nil>
where S is actually the symbol that names the function.")
SI:COMPILED-FUNCTION-NAME
#'"Function in SI package:
Syntax: (COMPILED-FUNCTION)

ECL specific.
Returns the function name associated with COMPILED-FUNCTION.
"
COMPILED-FUNCTION-P
#'"Function in COMMON-LISP package:
Syntax: (X)

Returns T if X is a compiled function object; NIL otherwise.
"
SI:COMPILER-LET
#'"Special Form in SI package:
Syntax: (compiler-let ({var | (var [value])}*) {form}*)

When interpreted, this form works just like a LET form with all VARs declared
special.  When compiled, FORMs are processed with the VARs bound at compile
time, but no bindings occur when the compiled code is executed.
"
COMPLEMENT
#'"Args: (f)
Returns a new function which first applies F to its arguments and then negates
the output"
COMPLEX
(FUNCTION "Function in COMMON-LISP package:
Syntax: (REALPART &OPTIONAL (IMAGPART 0))

Returns a complex number with the given realpart and imagpart.  Returns
REALPART if it is a rational and IMAGPART is 0.
" TYPE "
A complex number represents a complex number in mathematical sense, consisting
of a real part and an imaginary part.  A complex number is notated as
	#c( realpart  imagpart )  or  #C( realpart  imagpart )
where REALPART and IMAGPART are non-complex numbers.")
COMPLEXP
#'"Function in COMMON-LISP package:
Syntax: (X)

Returns T if X is a complex number; NIL otherwise.
"
CONCATENATE
#'"Args: (type &rest sequences)
Returns a new sequence of the specified type, consisting of all elements of
SEQUENCEs."
COND
#'"Syntax: (cond {(test {form}*)}*)
Evaluates TESTs in order until one evaluates to non-NIL.  Then evaluates FORMs
in order that follow the TEST and returns all values of the last FORM.  If no
forms follow the TEST, then returns the value of the TEST.  Returns NIL, if no
TESTs evaluates to non-NIL."
CONJUGATE
#'"Function in COMMON-LISP package:
Syntax: (NUMBER)

Returns the complex conjugate of NUMBER.  Returns NUMBER if it is not a
complex number.
"
CONS
(FUNCTION "Function in COMMON-LISP package:
Syntax: (X Y)

Returns a new cons whose car and cdr are X and Y respectively.
" TYPE "
A cons is a compound object consisting of two components car and cdr.")
CONSP
#'"Function in COMMON-LISP package:
Syntax: (X)

Returns T if X is a cons; NIL otherwise.
"
CONSTANTLY
#'"Args: (n)
Builds a new function which accepts any number of arguments but always outputs N."
CONSTANTP
#'"Function in COMMON-LISP package:
Syntax: (X)

Returns T if ECL is sure that X, when given as a form, always evaluates to a
same value.  Returns NIL otherwise.  Typically used to check whether a symbol
names a constant variable.
"
COPY-ALIST
#'"Function in COMMON-LISP package:
Syntax: (ALIST)

Returns a new list consisting of copies of all pairs in ALIST.
"
COPY-LIST
#'"Function in COMMON-LISP package:
Syntax: (LIST)

Returns a new list consisting of all elements in LIST.
"
COPY-READTABLE
#'"Function in COMMON-LISP package:
Syntax: (&OPTIONAL (READTABLE *READTABLE*) (TO-READTABLE NIL))

Returns a new copy of READTABLE.  If TO-READTABLE is non-NIL, then copies the
contents of READTABLE into TO-READTABLE and returns TO-READTABLE.
"
COPY-SEQ
#'"Function in COMMON-LISP package:
Syntax: (SEQUENCE)

Returns a new copy of SEQUENCE.
"
COPY-SYMBOL
#'"Function in COMMON-LISP package:
Syntax: (SYMBOL &OPTIONAL (FLAG NIL))

Returns a new uninterned symbol with the same print name as SYMBOL.  If FLAG
is NIL, the symbol property of the new symbol is empty.  Otherwise, the new
symbol gets a copy of the property list of SYMBOL.
"
COPY-TREE
#'"Function in COMMON-LISP package:
Syntax: (TREE)

Returns a copy of TREE.  Defined as:
	(defun copy-tree (tree)
	  (if (atom tree)
	      tree
	      (cons (copy-tree (car tree)) (copy-tree (cdr tree)))))
"
COS
#'"Function in COMMON-LISP package:
Syntax: (RADIANS)

Returns the cosine of RADIANS.
"
COSH
#'"Function in COMMON-LISP package:
Syntax: (NUMBER)

Returns the hyperbolic cosine of NUMBER.
"
COUNT
#'"Function in COMMON-LISP package:
Syntax: (ITEM SEQUENCE &KEY (KEY '#'IDENTITY) (TEST '#'EQL) TEST-NOT (START 0) (END (LENGTH SEQUENCE)) (FROM-END NIL))

Returns the number of elements in SEQUENCE satisfying TEST with ITEM as the
first argument.
"
COUNT-IF
#'"Function in COMMON-LISP package:
Syntax: (TEST SEQUENCE &KEY (KEY '#'IDENTITY) (START 0) (END (LENGTH SEQUENCE)) (FROM-END NIL))

Returns the number of elements in SEQUENCE satisfying TEST.
"
COUNT-IF-NOT
#'"Function in COMMON-LISP package:
Syntax: (TEST SEQUENCE (START 0) (END (LENGTH SEQUENCE)) (FROM-END NIL))

Returns the number of elements in SEQUENCE not satisfying TEST.
"
CTYPECASE
#'"Syntax: (ctypecase place {(type {form}*)}*)
Searches a TYPE to which the value of PLACE belongs.  If found, then evaluates
FORMs that follow the TYPE and returns all values of the last FORM.  If no
such TYPE is found, signals a continuable error.  Before continuing, receives
a new value of PLACE from the user and searches an appropriate TYPE again.
Repeats this process until the value of PLACE becomes of one of the TYPEs."
SI::DAYLIGHT-SAVING-TIME-P
#'"Returns T if Daylight Saving Time applies to the local time zone at
Universal Time UT, which defaults to the current time."
DECF
#'"Syntax: (decf place [form])
Decrements the value of PLACE by the value of FORM.  FORM defaults to 1."
DECLARE
#'"Special Form in COMMON-LISP package:
Syntax: (declare {decl-spec}*)

Gives declarations.  Possible DECL-SPECs are:
  (SPECIAL {var}*)
  (TYPE type {var}*)
  (type {var}*) where 'type' is one of the following symbols
	array		fixnum		package		simple-string
	atom		float		pathname	simple-vector
	bignum		function	random-state	single-float
	bit		hash-table	ratio		standard-char
	bit-vector	integer		rational	stream
	character	keyword		readtable	string
	common		list		sequence	string-char
	compiled-function  long-float	short-float	symbol
	complex		nil		signed-byte	t
	cons		null		simple-array	unsigned-byte
	double-float	number		simple-bit-vector  vector
  (OBJECT {var}*)
  (FTYPE type {function-name}*)
  (FUNCTION function-name ({arg-type}*) {return-type}*)
  (INLINE {function-name}*)
  (NOTINLINE {function-name}*)
  (IGNORE {var}*)
  (OPTIMIZE {({SPEED | SPACE | SAFETY | COMPILATION-SPEED} {0 | 1 | 2 | 3})}*)
  (DECLARATION {non-standard-decl-name}*)
  (:READ-ONLY {variable-name}*).
"
DECODE-FLOAT
#'"Function in COMMON-LISP package:
Syntax: (FLOAT)

Returns the significand F, the exponent E, and the sign S of FLOAT.  These
values satisfy
	1/B <= F < 1
and			 E
	FLOAT = S * F * B
where B is the radix used to represent FLOAT.  S and F are floats of the same
float format as FLOAT, and E is an integer.
"
DECODE-UNIVERSAL-TIME
#'"Args: (integer &optional (timezone (si::get-local-time-zone)))
Returns as nine values the day-and-time represented by INTEGER.  See GET-
DECODED-TIME."
FFI:DEF-CONSTANT
#'"Macro to define a constant and to export it"
FFI:DEFCBODY
#'"Syntax: (defcbody symbol ({arg-type}*) value-type body)"
DEFCONSTANT
#'"Syntax: (defconstant symbol form [doc])

Declares that the global variable named by SYMBOL is a constant with the value
of FORM as its constant value.  The doc-string DOC, if supplied, is saved as a
VARIABLE doc and can be retrieved by (DOCUMENTATION 'SYMBOL 'VARIABLE)."
FFI:DEFENTRY
#'"Syntax: (defentry symbol ({arg-type}*) (value-type function-name))

The compiler defines a Lisp function named by SYMBOL whose body consists of a
calling sequence to the C language function named by FUNCTION-NAME.  The
interpreter ignores this form.  ARG-TYPEs are argument types of the C function
and VALUE-TYPE is the return type of the C function.  Symbols OBJECT, INT,
CHAR, CHAR*, FLOAT, DOUBLE are allowed for these types."
DEFINE-MODIFY-MACRO
#'"Syntax: (define-modify-macro symbol lambda-list function-name [doc])
Defines a read-modify-write macro like INCF.  The defined macro will expand
a form (SYMBOL place form1 ... formn) into a form that in effect SETFs the
value of (FUNCTION-NAME place arg1 ... argm) into PLACE, where ARG1 ... ARGm
are parameters in LAMBDA-LIST which are bound to FORM1 ... FORMn.  For
example, INCF could be defined as
	(define-modify-macro incf (&optional (x 1)) +)
The doc-string DOC, if supplied, is saved as a FUNCTION doc and can be
retrieved by (DOCUMENTATION 'SYMBOL 'FUNCTION)."
DEFINE-SETF-EXPANDER
#'"Syntax: (define-setf-expander symbol defmacro-lambda-list {decl | doc}*
          {form}*)
Defines the SETF-method for generalized-variables (SYMBOL ...).
When a form (setf (SYMBOL arg1 ... argn) value-form) is evaluated, the FORMs
given in the DEFINE-SETF-EXPANDER are evaluated in order with the parameters in
DEFMACRO-LAMBDA-LIST bound to ARG1 ... ARGn.  The last FORM must return five
values
	(var1 ... vark)
	(form1 ... formk)
	(value-var)
	storing-form
	access-form
in order.  These values are collectively called the five gangs of the
generalized variable (SYMBOL arg1 ... argn).  The whole SETF form is then
expanded into
	(let* ((var1 from1) ... (vark formk)
	       (value-var value-form))
	  storing-form)
The doc-string DOC, if supplied, is saved as a SETF doc and can be retrieved
by (DOCUMENTATION 'SYMBOL 'SETF)."
FFI:DEFINLINE
#'"Syntax: (definline symbol ({arg-type}*) value-type body)"
FFI:DEFLA
#'"Syntax: (defla name lambda-list {decl | doc}* {form}*)"
DEFPACKAGE
#'"DEFPACKAGE - DEFINED-PACKAGE-NAME {OPTION}*			[Macro]

   This creates a new package, or modifies an existing one, whose name is
   DEFINED-PACKAGE-NAME.  The DEFINED-PACKAGE-NAME may be a string or a 
   symbol; if it is a symbol, only its print name matters, and not what
   package, if any, the symbol happens to be in.  The newly created or 
   modified package is returned as the value of the DEFPACKAGE form.

   Each standard OPTION is a list of keyword (the name of the option)
   and associated arguments.  No part of a DEFPACKAGE form is evaluated.
   Except for the :SIZE and :DOCUMENTATION options, more than one option 
   of the same kind may occur within the same DEFPACKAGE form.

  Valid Options:
	(:documentation		string)
	(:size			integer)
	(:nicknames		{package-name}*)
	(:shadow		{symbol-name}*)
	(:shadowing-import-from	package-name {symbol-name}*)
	(:use			{package-name}*)
	(:import-from		package-name {symbol-name}*)
	(:intern		{symbol-name}*)
	(:export		{symbol-name}*)
	(:export-from		{package-name}*)

  [Note: :EXPORT-FROM is an extension to DEFPACKAGE.
	 If a symbol is interned in the package being created and
	 if a symbol with the same print name appears as an external
	 symbol of one of the packages in the :EXPORT-FROM option,
	 then the symbol is exported from the package being created.

	 :DOCUMENTATION is an extension to DEFPACKAGE.

	 :SIZE is used only in Genera and Allegro.]"
DEFPARAMETER
#'"Syntax: (defparameter name form [doc])
Declares the global variable named by NAME as a special variable and assigns
the value of FORM to the variable.  The doc-string DOC, if supplied, is saved
as a VARIABLE doc and can be retrieved by (documentation 'NAME 'variable)."
DEFSETF
#'"Syntax: (defsetf symbol update-fun [doc])
	or
	(defsetf symbol lambda-list (store-var) {decl | doc}* {form}*)
Defines an expansion
	(setf (SYMBOL arg1 ... argn) value)
	=> (UPDATE-FUN arg1 ... argn value)
	   or
	   (let* ((temp1 ARG1) ... (tempn ARGn) (temp0 value)) rest)
where REST is the value of the last FORM with parameters in LAMBDA-LIST bound
to the symbols TEMP1 ... TEMPn and with STORE-VAR bound to the symbol TEMP0.
The doc-string DOC, if supplied, is saved as a SETF doc and can be retrieved
by (documentation 'SYMBOL 'setf)."
DEFSTRUCT
#'"Syntax: (defstruct
         {name | (name {:conc-name | (:conc-name prefix-string) |
                        :constructor | (:constructor symbol [lambda-list]) |
                        :copier | (:copier symbol) |
                        :predicate | (:predicate symbol) |
                        (:include symbol) |
                        (:print-function function) |
                        (:print-object function) |
                        (:type {vector | (vector type) | list}) |
                        :named |
                        (:initial-offset number)}*)}
         [doc]
         {slot-name |
          (slot-name [default-value-form] {:type type | :read-only flag}*) }*
         )
Defines a structure named by NAME.  The doc-string DOC, if supplied, is saved
as a STRUCTURE doc and can be retrieved by (documentation 'NAME 'structure)."
DEFTYPE
#'"Syntax: (deftype name lambda-list {decl | doc}* {form}*)
Defines a new type-specifier abbreviation in terms of an 'expansion' function
	(lambda lambda-list1 {DECL}* {FORM}*)
where LAMBDA-LIST1 is identical to LAMBDA-LIST except that all optional
parameters with no default value specified in LAMBDA-LIST defaults to the
symbol '*', but not to NIL.  When the type system of ECL encounters a type
specifier (NAME arg1 ... argn), it calls the expansion function with the
arguments ARG1 ... ARGn, and uses the returned value instead of the original
type specifier.  When the symbol NAME is used as a type specifier, the
expansion function is called with no argument.
The doc-string DOC, if supplied, is saved as a TYPE doc and can be retrieved
by (documentation 'NAME 'type)."
DEFVAR
#'"Syntax: (defvar name [form [doc]])
Declares the variable named by NAME as a special variable.  If the variable
does not have a value, then evaluates FORM and assigns the value to the
variable.  FORM defaults to NIL.  The doc-string DOC, if supplied, is saved
as a VARIABLE doc and can be retrieved by (documentation 'NAME 'variable)."
DELETE
#'"Function in COMMON-LISP package:
Syntax: (ITEM SEQUENCE &KEY (KEY '#'IDENTITY) (TEST '#'EQL) TEST-NOT (START 0) (END (LENGTH SEQUENCE)) (COUNT MOST-POSITIVE-FIXNUM) (FROM-END NIL))

Destructive REMOVE.  SEQUENCE may be destroyed.
"
DELETE-DUPLICATES
#'"Args: (sequence &key key
		     (test '#'eql) test-not
                     (start 0) (end (length sequence)) (from-end nil))
Destructive REMOVE-DUPLICATES.  SEQUENCE may be destroyed."
DELETE-FILE
#'"Function in COMMON-LISP package:
Syntax: (FILESPEC)

Deletes the specified file.  FILESPEC may be a symbol, a string, a pathname,
or a file stream.
"
DELETE-IF
#'"Function in COMMON-LISP package:
Syntax: (TEST SEQUENCE &KEY (KEY '#'IDENTITY) (START 0) (END (LENGTH SEQUENCE)) (COUNT MOST-POSITIVE-FIXNUM) (FROM-END NIL))

Destructive REMOVE-IF.  SEQUENCE may be destroyed
"
DELETE-IF-NOT
#'"Function in COMMON-LISP package:
Syntax: (TEST SEQUENCE &KEY (KEY '#'IDENTITY) (START 0) (END (LENGTH SEQUENCE)) (COUNT MOST-POSITIVE-FIXNUM) (FROM-END NIL))

Destructive REMOVE-IF-NOT.  SEQUENCE may be destroyed
"
DENOMINATOR
#'"Function in COMMON-LISP package:
Syntax: (RATIONAL)

Returns the denominator of RATIONAL as a positive integer, if RATIONAL is a
ratio.  Returns RATIONAL if it is an integer.
"
DEPOSIT-FIELD
#'"Args: (integer1 bytespec integer2)
Returns an integer represented by the bit sequence obtained by replacing the
specified bits of INTEGER2 with the specified bits of INTEGER1."
DESCRIBE
#'"Args: (object &optional (stream *standard-output*))
Prints information about OBJECT to STREAM."
DIGIT-CHAR
#'"Function in COMMON-LISP package:
Syntax: (DIGIT &OPTIONAL (N 10) (FONT 0))

Returns a character that represents the DIGIT in radix N.  Returns NIL if no
such character exists.
"
DIGIT-CHAR-P
#'"Function in COMMON-LISP package:
Syntax: (CHAR &OPTIONAL (N 10))

If CHAR represents a digit in radix N, then returns an integer represented by
that digit.  Otherwise, returns NIL.
"
DIRECTORY
#'"Function in COMMON-LISP package:
Syntax: (FILESPEC)

Returns a list of full pathnames of all those files that match FILESPEC.
FILESPEC may be a symbol, a string, a pathname, or a file stream.
"
DIRECTORY-NAMESTRING
#'"Function in COMMON-LISP package:
Syntax: (FILESPEC)

Returns as a string the directory part of the pathname specified by FILESPEC.
FILESPEC may be a symbol, a string, a pathname, or a file stream.
"
SI::DISPLACED-ARRAY-P
#'"Function in SI package:
Syntax: (ARRAY)

ECL specific.
Returns T if the ARRAY is displaced to another array; NIL otherwise.
"
DO
#'"Macro in COMMON-LISP package:
Syntax: (do ({(var [init [step]])}*) (test {result}*)
          {decl}* {tag | statement}*)

Establishes a NIL block, binds each VAR to the value of the corresponding INIT
(which defaults to NIL), and then executes STATEMENTs repeatedly until TEST is
satisfied.  After each iteration, evaluates STEP and assigns the value to the
corresponding VAR.  No assignment occurs for those VARs to which STEP is not
given.  When TEST is satisfied, evaluates RESULTs as a PROGN and returns all
values of the last RESULT.  Performs variable bindings and assignments in
parallel, just as LET and PSETQ do.
"
DO*
#'"Macro in COMMON-LISP package:
Syntax: (do* ({(var [init [step]])}*) (test {result}*)
          {decl}* {tag | statement}*)

Similar to DO, but performs variable bindings and assignments in serial, just
as LET* and SETQ do.
"
DO-ALL-SYMBOLS
#'"Syntax: (do-all-symbols (var [result]) {decl}* {tag | statement}*)
Establishes a NIL block and executes STATEMENTs once for each symbol in each
package, with VAR bound to the symbol.  Then evaluates RESULT (which defaults
to NIL) and returns all values."
DO-EXTERNAL-SYMBOLS
#'"Syntax: (do-external-symbols (var [package [result]])
          {decl}* {tag | statement}*)
Establishes a NIL block and executes STATEMENTs once for each external symbol
in PACKAGE (which defaults to the current package), with VAR bound to the
variable.  Then evaluates RESULT (which defaults to NIL) and returns all
values."
DO-SYMBOLS
#'"Syntax: (do-symbols (var [package [result]])
          {decl}* {tag | statement}*)
Executes STATEMENTs once for each symbol in PACKAGE (which defaults to the
current package), with VAR bound to the symbol.  Then evaluates RESULT (which
defaults to NIL) and returns all values."
DOLIST
#'"Macro in COMMON-LISP package:
Syntax: (dolist (var form [result])
          {decl}* {tag | statement}*)

Establishes a NIL block and executes STATEMENTs once for each member of the
list value of FORM, with VAR bound to the member.  Then evaluates RESULT
(which defaults to NIL) and returns all values.
"
DOTIMES
#'"Macro in COMMON-LISP package:
Syntax: (dotimes (var form [result])
          {decl}* {tag | statement}*)

Establishes a NIL block and executes STATEMENTs once for each integer between
0 (inclusive) and the value of FORM (exclusive), with VAR bound to the
integer.  Then evaluates RESULT (which defaults to NIL) and returns all
values.
"
DOUBLE-FLOAT
(TYPE "
A double-float is a double-precision floating point number.
DOUBLE-FLOAT as a type specifier is equivalent to LONG-FLOAT in ECL.")
DOUBLE-FLOAT-EPSILON
(VARIABLE "The smallest postive double-float E that satisfies
	(not (= (float 1 E) (+ (float 1 E) E)))")
DOUBLE-FLOAT-NEGATIVE-EPSILON
(VARIABLE "The smallest positive double-float E that satisfies
	(not (= (float 1 E) (- (float 1 E) E)))")
DPB
#'"Args: (newbyte bytespec integer)
Replaces the specified byte of INTEGER with NEWBYTE (an integer) and returns
the result."
DRIBBLE
#'"Args: (&optional filespec)
If FILESPEC is given, starts recording the interaction to the specified file.
FILESPEC may be a symbol, a string, a pathname, or a file stream.  If FILESPEC
is not given, ends the recording."
ECASE
#'"Syntax: (ecase keyform {({key | ({key}*)} {form}*)}*)
Evaluates KEYFORM and tries to find the KEY that is EQL to the value of
KEYFORM.  If found, then evaluates FORMs that follow the KEY (or the key list
that contains the KEY) and returns all values of the last FORM.  If not,
signals an error."
ED
#'"Args: (&optional filename)
Invokes the editor.  The action depends on the version of ECL.  See the ECL
Report for details."
EIGHTH
#'"Function in COMMON-LISP package:
Syntax: (X)

Equivalent to (CADDDR (CDDDDR X)).
"
ELT
#'"Function in COMMON-LISP package:
Syntax: (SEQUENCE N)

Returns the N-th element of SEQUENCE.
"
ENCODE-UNIVERSAL-TIME
#'"Args: (second minute hour date month year
       &optional (timezone (si::get-local-time-zone)))
Returns an integer that represents the given day-and-time.  See
GET-DECODED-TIME."
ENDP
#'"Function in COMMON-LISP package:
Syntax: (X)

Returns T if X is NIL.  Returns NIL if X is a cons.  Otherwise, signals an
error.
"
ENOUGH-NAMESTRING
#'"Function in COMMON-LISP package:
Syntax: (FILESPEC &OPTIONAL (DEFAULTS *DEFAULT-PATHNAME-DEFAULTS*))

Returns a string which uniquely identifies the file specified by FILESPEC,
with respect to DEFAULTS.  FILESPEC and DEFAULTS may be a symbol, a string, a
pathname, or a file stream.
"
ENSURE-DIRECTORIES-EXIST
#'"Args: (ensure-directories pathname &key :verbose)
Creates tree of directories specified by the given pathname. Outputs
	(VALUES pathname created)
where CREATED is true only if we succeeded on creating all directories."
EQ
#'"Function in COMMON-LISP package:
Syntax: (X Y)

Returns T if the args are identical; NIL otherwise.
"
EQL
#'"Function in COMMON-LISP package:
Syntax: (X Y)

Returns T if the args satisfy one of the following conditions.
	1. identical
	2. are numbers of the same type with the same value
	3. are characters that represent the same character
Returns NIL otherwise.
"
EQUAL
#'"Function in COMMON-LISP package:
Syntax: (X Y)

Returns T if the args satisfy one of the following conditions.
	1. EQL
	2. are conses with EQUAL cars and EQUAL cdrs
	3. are strings of the same length and element-wise EQL
	4. are bit-vectors of the same length and element-wise EQL
	5. are pathnames with EQUAL slots
Returns NIL otherwise.
"
EQUALP
#'"Function in COMMON-LISP package:
Syntax: (X Y)

Returns T if the args satisfy one of the following conditions.
	1. EQUAL
	2. are characters that satisfy CHARACTER-EQUAL
	3. are numbers that satisfy =
	4. are conses with EQUALP cars and EQUALP cdrs
	5. are arrays of the same dimensions and element-wise EQUALP
Returns NIL otherwise.
"
ERROR
#'"Function in COMMON-LISP package:
Syntax: (FORMAT-STRING &REST ARGS)

Signals an error.  The args are FORMATed to *error-output*.
"
ETYPECASE
#'"Syntax: (etypecase keyform {(type {form}*)}*)
Evaluates KEYFORM and searches a TYPE to which the value of KEYFORM belongs.
If found, then evaluates FORMs that follow the TYPE and returns all values of
the last FORM.  If not, signals an error."
EVAL
#'"Function in COMMON-LISP package:
Syntax: (FORM)

Evaluates FORM and returns all values.
"
EVAL-WHEN
#'"Special Form in COMMON-LISP package:
Syntax: (eval-when ({situation}*) {form}*)

Specifies when to evaluate FORMs.  Each SITUATION must be one of the following
symbols.
	COMPILE	(compile-time)
	LOAD	(load-time of the fasl file)
	EVAL	(load-time of the source file)
"
SI::EVALHOOK
#'"Function in SI package:
Syntax: (FORM FUN1 FUN2 &OPTIONAL (ENV NIL))

Evaluates FORM with *EVALHOOK* bound to FUN1 and *APPLYHOOK* bound to FUN2,
and returns all the values.
"
EVENP
#'"Function in COMMON-LISP package:
Syntax: (INTEGER)

Returns T if INTEGER is an even number; NIL otherwise.
"
EVERY
#'"Args: (predicate sequence &rest more-sequences)
Returns T if every elements of SEQUENCEs satisfy PREDICATE; NIL otherwise."
SI::EVERY*
#'"Args: (predicate sequence &rest more-sequences)
Returns T if every elements of SEQUENCEs satisfy PREDICATE and all sequences
have the same length; NIL otherwise."
EXP
#'"Function in COMMON-LISP package:
Syntax: (NUMBER)

Returns E raised to the power NUMBER, where E is the base of natural
logarithms.
"
EXPORT
#'"Function in COMMON-LISP package:
Syntax: (SYMBOL &OPTIONAL (PACKAGE *PACKAGE*))

Register SYMBOL as an external symbol of PACKAGE.  SYMBOL may be a list of
symbols.
"
EXPT
#'"Function in COMMON-LISP package:
Syntax: (NUMBER1 NUMBER2)

Returns NUMBER1 raised to the power NUMBER2.
"
EXTENDED-CHAR
(TYPE "A character which is not of type BASE-CHAR.")
SI:EXTENDED-STRING
(TYPE "A string which is nt a base string")
FBOUNDP
#'"Function in COMMON-LISP package:
Syntax: (SYMBOL)

Returns T if SYMBOL names a special form, a global macro, or a global
function.  Returns NIL otherwise.
"
FCEILING
#'"Args: (number &optional (divisor 1))
Same as CEILING, but returns a float as the first value."
FFLOOR
#'"Args: (number &optional (divisor 1))
Same as FLOOR, but returns a float as the first value."
FIFTH
#'"Function in COMMON-LISP package:
Syntax: (X)

Equivalent to (CAR (CDDDDR X)).
"
FILE-AUTHOR
#'"Function in COMMON-LISP package:
Syntax: (FILESPEC)

Returns the author of the specified file, as a string.  Returns NIL if the
author is unknown.  FILESPEC may be a symbol, a string, a pathname, or a file
stream.
"
FILE-LENGTH
#'"Function in COMMON-LISP package:
Syntax: (FILE-STREAM)

Returns the length of the specified FILE-STREAM.  Returns NIL if the length is
unknown.
"
FILE-NAMESTRING
#'"Function in COMMON-LISP package:
Syntax: (FILESPEC)

Returns as a string the name, type, and version parts of the specified
pathname.  FILESPEC may be a symbol, a string, a pathname, or a file stream.
"
FILE-POSITION
#'"Function in COMMON-LISP package:
Syntax: (FILE-STREAM &OPTIONAL FILE-POSITION)

With one arg, returns the current position of FILE-STREAM's file pointer as a
non-negative integer.  Returns NIL if the position is unknown.  With two args,
resets the file pointer and returns T.  Returns NIL if the file pointer cannot
be reset.  FILE-POSITION may be a non-negative integer, :START, or :END.
"
FILE-WRITE-DATE
#'"Function in COMMON-LISP package:
Syntax: (FILESPEC)

Returns an integer that represents the last write day-and-time of the
specified file (See GET-DECODED-TIME).   Returns NIL if the last write day-
and-time is unknown.  FILESPEC may be a symbol, a string, a pathname, or a
file stream.
"
FILL
#'"Function in COMMON-LISP package:
Syntax: (SEQUENCE ITEM &KEY (START 0) (END (LENGTH SEQUENCE)))

Replaces the specified elements of SEQUENCE with ITEM.
"
FILL-POINTER
#'"Function in COMMON-LISP package:
Syntax: (VECTOR)

Returns the fill-pointer of VECTOR as an integer.  VECTOR must have a fill-
pointer.
"
FIND
#'"Function in COMMON-LISP package:
Syntax: (ITEM SEQUENCE &KEY (KEY '#'IDENTITY) (TEST '#'EQL) TEST-NOT (START 0) (END (LENGTH SEQUENCE)) (FROM-END NIL))

Returns the first element in SEQUENCE satisfying TEST with ITEM.  Returns NIL
if no such element exists.
"
FIND-ALL-SYMBOLS
#'"Args: (string-designator)
Returns a list of all symbols that have the specified print name.
STRING-DESIGNATOR may be a symbol, in which case the print name of the symbol
is used."
FIND-IF
#'"Function in COMMON-LISP package:
Syntax: (TEST SEQUENCE &KEY (KEY '#'IDENTITY) (START 0) (END (LENGTH SEQUENCE)) (FROM-END NIL))

Returns the index of the first element in SEQUENCE that satisfies TEST.
Returns NIL if no such element exists.
"
FIND-IF-NOT
#'"Function in COMMON-LISP package:
Syntax: (TEST SEQUENCE &KEY (KEY '#'IDENTITY) (START 0) (END (LENGTH SEQUENCE)) (FROM-END NIL))

Returns the index of the first element in SEQUENCE that does not satisfy TEST.
Returns NIL if no such element exists.
"
FIND-PACKAGE
#'"Function in COMMON-LISP package:
Syntax: (NAME)

Returns the package whose package name or nickname is NAME.  Returns NIL if no
such package exists.  NAME may be a string or a symbol.
"
FIND-SYMBOL
#'"Function in COMMON-LISP package:
Syntax: (STRING &OPTIONAL (PACKAGE *PACKAGE*))

Searches PACKAGE for a symbol whose print name is NAME.  If such a symbol is
found, then returns the symbol as the first value and returns one of the
following symbols as the second value.
	:INTERNAL (internal symbol in PACKAGE)
	:EXTERNAL (external symbol in PACKAGE)
	:INHERITED (external symbol of a package that PACKAGE is using)
If no such symbol is found, returns NIL as the first and second values.
"
FINISH-OUTPUT
#'"Function in COMMON-LISP package:
Syntax: (&OPTIONAL (STREAM *STANDARD-OUTPUT*))

Sends the contents of the output buffer for STREAM to the destination.  Waits
until the buffer becomes empty and then returns NIL.
"
FIRST
#'"Function in COMMON-LISP package:
Syntax: (X)

Equivalent to CAR.
"
FIXNUM
(TYPE "A FIXNUM is an integer between MOST-NEGATIVE-FIXNUM (= - 2^29 in ECL) and
MOST-POSITIVE-FIXNUM (= 2^29 - 1 in ECL) inclusive.  Other integers are
bignums.")
SI:FIXNUMP
#'"Function in SI package:
Syntax: (X)

ECL specific.
Returns T if the X is a fixnum; NIL otherwise.
"
FLET
#'"Special Form in COMMON-LISP package:
Syntax: (flet ({(name lambda-list {decl | doc}* {form}*)}*) . body)

Introduces local functions and evaluates BODY as a PROGN.  BODY is the scope
of each local function but the local function definitions are not.  Thus each
local function can reference externally defined functions of the same name as
local functions.  Doc-strings for local functions are simply ignored.
"
FLOAT
(FUNCTION "Function in COMMON-LISP package:
Syntax: (NUMBER &OPTIONAL FLOAT)

With one arg, converts NUMBER to a single-float.  With two args, converts
NUMBER to a float of the same float format as FLOAT.
" TYPE "
A float (floating-point number) represents a real number or its approximation.
ECL supports two formats for floats.  One format is called SHORT-FLOAT and the
other format is called SINGLE-FLOAT, DOUBLE-FLOAT, or LONG-FLOAT.  Precisions
and exponent sizes of floats depends on the version of ECL.  See the ECL
Report at your hand for details.
The following syntax is used to notate a float.
	[+ | -] {digit}* . {digit}+ [exp]
	[+ | -] {digit}+ [. {digit}*}] exp
where DIGIT is a decimal digit (0,..,9) and EXP is
	marker [+ | -] {digit}+
with one of the following marker.
	e or E	the default float format
	s or S	short-float
	f or F	single-float
	d or D	double-float
	l or L	long-float
The default float format is single-float normally, but may be any other float
format.  See *READ-DEFAULT-FLOAT-FORMAT*.")
FLOAT-DIGITS
#'"Function in COMMON-LISP package:
Syntax: (FLOAT)

Returns the number of radix-B digits used to represent the significand of
FLOAT, where B is the base number used in the representation of FLOAT.
"
FLOAT-PRECISION
#'"Function in COMMON-LISP package:
Syntax: (FLOAT)

Returns the number of effective radix-B digits in the representation of the
significand of FLOAT, where B is the base number used in the representation
of FLOAT.
"
FLOAT-RADIX
#'"Function in COMMON-LISP package:
Syntax: (FLOAT)

Returns the base number used in the representation of FLOAT.
"
FLOAT-SIGN
#'"Function in COMMON-LISP package:
Syntax: (FLOAT1 &OPTIONAL (FLOAT2 (FLOAT 1 FLOAT1)))

Returns a float with the same sign as FLOAT1 and with the same absolute value
as FLOAT2.
"
FLOATP
#'"Function in COMMON-LISP package:
Syntax: (X)

Returns T if X is a float; NIL otherwise.
"
FLOOR
#'"Function in COMMON-LISP package:
Syntax: (NUMBER &OPTIONAL (DIVISOR 1))

Returns the largest integer not larger than the NUMBER divided by DIVISOR.
Returns the value of (- NUMBER (* first-value DIVISOR)) as the second value.
"
FMAKUNBOUND
#'"Function in COMMON-LISP package:
Syntax: (SYMBOL)

Removes the global function definition associated with SYMBOL.  Returns SYMBOL.
"
FORCE-OUTPUT
#'"Function in COMMON-LISP package:
Syntax: (&OPTIONAL (STREAM *STANDARD-OUTPUT*))

Sends the contents of the output buffer for STREAM to the destination.
Returns NIL without waiting until the buffer becomes empty.
"
FORMAT
#'"Function in COMMON-LISP package:
Syntax: (DESTINATION FORMAT-STRING &REST ARGS)

Outputs ARGs to DESTINATION in the format specified by FORMAT-STRING.  FORMAT-
STRING is a string consisting of characters to output and format directives
which begin with '~~'.  Outputs to DESTINATION if it is a stream and to the
standard output if DESTINATION is T.  If DESTINATION is NIL, does not output
actually but returns the output as a string.  Here are some format directives:
	~~A	PRINCs one arg
	~~S	PRIN1s one arg
	~~D	Prints one integer in decimal
	~~B	Prints one integer in binary
	~~O	Prints one integer in octal
	~~X	Prints one integer in hexa
	~~%	Does TERPRI
	~~&	Does FRESH-LINE
	~~|	Outputs #\\Page
	~~~~	Outputs '~~'
"
FOURTH
#'"Function in COMMON-LISP package:
Syntax: (X)

Equivalent to CADDDR.
"
FRESH-LINE
#'"Function in COMMON-LISP package:
Syntax: (&OPTIONAL (STREAM *STANDARD-OUTPUT*))

Outputs a newline character only if the current position of STREAM is not at
the beginning of a line.  Returns T if it outputs a newline; NIL otherwise.
"
FROUND
#'"Args: (number &optional (divisor 1))
Same as ROUND, but returns a float as the first value."
SI:FRS-BDS
#'"Function in SI package:
Syntax: (N)

ECL specific.
Returns the bind stack index of the N-th entity in the frame stack.
"
SI:FRS-IHS
#'"Function in SI package:
Syntax: (N)

ECL specific.
Returns the invocation history stack index of the N-th entity in the frame
stack.
"
FTRUNCATE
#'"Args: (number &optional (divisor 1))
Same as TRUNCATE, but returns a float as the first value."
FUNCALL
#'"Function in COMMON-LISP package:
Syntax: (FUNCTION &REST ARGS)

Calls FUNCTION with the ARGs as the arguments and returns all values that the
call returns.
"
FUNCTION
(FUNCTION "Special Form in COMMON-LISP package:
Syntax: (function x) | #'x

If X is a lambda expression, creates and returns a lexical closure of X in the
current lexical environment.  If X is a symbol that names a function, returns
that function definition.
" TYPE "
A function object specifies a function to be invoked by function-calling
functions such as FUNCALL or APPLY.  A function is either:
	1. a compiled function
	2. a list of one of the following form
		(lambda lambda-list . body)
		(lambda-block block-name lambda-list . body)
		(lambda-closure env1 env2 env3 lambda-list . body)
		(lambda-block-closure env1 env2 env3 block-name lambda-list
		                      . body)
	   where ENV1, ENV2, and ENV3 respectively represent the variable
	   environment, the function/macro environment, and the block/tagbody
	   environment at the time of the function creation.
	3. a symbol that names a global function.")
FUNCTIONP
#'"Function in COMMON-LISP package:
Syntax: (X)

Returns T if X is an object that can be used to specify a function to be
invoked by function-calling functions such as FUNCALL or APPLY.  Returns NIL
otherwise.
"
SI:GC
#'"Function in SI package:
Syntax: (X)

ECL specific.
Starts garbage collection with the specified collection level.  If X is NIL,
collects only cells.  If X is T, collects everything.
"
GCD
#'"Function in COMMON-LISP package:
Syntax: (&REST INTEGERS)

Returns the greatest common divisor of the args.
"
GENSYM
#'"Function in COMMON-LISP package:
Syntax: (&OPTIONAL (X NIL))

Creates and returns a new uninterned symbol whose print name begins with some
prefix (initially \"G\"), followed by a generation number.  The generation
number is incremented by one at each call to GENSYM.  If X is an integer, it
becomes the new generation number.  If X is a string, it becomes the new
prefix.
"
GENTEMP
#'"Function in COMMON-LISP package:
Syntax: (&OPTIONAL (STRING \"T\") (PACKAGE *PACKAGE*))

Creates a new symbol interned in PACKAGE with PREFIX and returns the symbol.
The symbol is given a print name beginning with PREFIX followed by some
generation number.
"
GET
#'"Function in COMMON-LISP package:
Syntax: (SYMBOL PROPERTY &OPTIONAL (DEFAULT NIL))

Searches the symbol property of SYMBOL for a property that is EQ to PROPERTY.
If found, returns the value of the property.  Otherwise, returns DEFAULT.
"
GET-DECODED-TIME
#'"Args: ()
Returns the current day-and-time as nine values:
	second (0 - 59)
	minute (0 - 59)
	hour (0 - 23)
	date (1 - 31)
	month (1 - 12)
	year (Christian, not Japanese long-live-Emperor)
	day of week (0 for Mon, .. 6 for Sun)
	summer time or not (T or NIL)
	time zone (-9 in Japan)
Sunday is the *last* day of the week!!"
GET-DISPATCH-MACRO-CHARACTER
#'"Function in COMMON-LISP package:
Syntax: (CHAR SUBCHAR &OPTIONAL (READTABLE *READTABLE*))

Returns the read macro for SUBCHAR associated with the dispatch macro
character CHAR in READTABLE.
"
GET-INTERNAL-REAL-TIME
#'"Function in COMMON-LISP package:
Syntax: NIL

Returns the time (in 1/100 seconds) since the invocation of ECL.
"
GET-INTERNAL-RUN-TIME
#'"Function in COMMON-LISP package:
Syntax: NIL

Returns the CPU time (in 1/100 seconds) since the invocation of ECL.
"
GET-MACRO-CHARACTER
#'"Function in COMMON-LISP package:
Syntax: (CHAR &OPTIONAL (READTABLE *READTABLE*))

Returns the read macro associated with the macro character CHAR in READTABLE.
Returns the non-terminating-p flag (see READTABLE) as the second value.
Returns NIL if CHAR is not a macro character.
"
GET-OUTPUT-STREAM-STRING
#'"Function in COMMON-LISP package:
Syntax: (STRING-OUTPUT-STREAM)

Returns as a string all outputs to STRING-OUTPUT-STREAM since the last call of
GET-OUTPUT-STREAM-STRING for the same stream.
"
GET-PROPERTIES
#'"Function in COMMON-LISP package:
Syntax: (PLIST LIST)

Searches PLIST for a property that is EQ to one of the members of LIST.
Returns three values.  If such a property if found, returns the property, the
value of the property, and the rest of LIST.  If not, returns three NILs.
"
GET-SETF-EXPANSION
#'"Args: (form)
Returns the 'five gangs' (see DEFINE-SETF-EXPANDER) for PLACE as five values.
Does not check if the third gang is a single-element list."
GET-UNIVERSAL-TIME
#'"Function in COMMON-LISP package:
Syntax: NIL

Returns the current day-and-time as an integer.  See DECODE-UNIVERSAL-TIME.
"
SI:GETCWD
#'"Function in SI package:
Syntax: (&OPTIONAL (UPDATE-LISP T))

Returns the current working directory of the C library. When UPDATE-LISP is
true, *DEFAULT-PATHNAME-DEFAULTS* is set to this value.
"
SI:GETENV
#'"Function in SI package:
Syntax: (STRING)

ECL/UNIX specific.
Returns the environment with the name STRING as a string.  Returns NIL, if the
specified environment is not found.
"
GETF
#'"Function in COMMON-LISP package:
Syntax: (PLIST PROPERTY &OPTIONAL (DEFAULT NIL))

Searches PLIST for a property that is EQ to PROPERTY.  If one is found,
returns the value of the property.  If not, returns DEFAULT.
The SETF form
	(setf (getf place property-form) value-form)
replaces the property value of the plist stored in PLACE, or adds a new
property if the plist does not have the property yet.
"
GETHASH
#'"Function in COMMON-LISP package:
Syntax: (KEY HASH-TABLE &OPTIONAL (DEFAULT NIL))

Searches HASH-TABLE for the entry of KEY.  If found, returns the value of the
entry and T, as two values.  If not, returns DEFAULT and NIL.
"
SI::GFUN-INSTANCE
#'"Function in SI package:
Syntax: (GFUN)

ECL/CLOS specific.
Returns the generic function instance associated with the GFUN
generic function object.
"
SI::GFUN-INSTANCE-SET
#'"Function in SI package:
Syntax: (GFUN INSTANCE)

ECL/CLOS specific.
Sets to INSTANCE the generic function instance associated with the
FUN generic function object.
"
SI::GFUN-METHOD-HT
#'"Function in SI package:
Syntax: (GFUN)

ECL/CLOS specific.
Returns the hashtable for caching methods associated with the GFUN
generic function object.
"
SI::GFUN-METHOD-HT-SET
#'"Function in SI package:
Syntax: (GFUN HASH-TABLE)

ECL/CLOS specific.
Sets to HASH-TABLE the hashtable for caching methods associated with the
GFUN generic function object.
"
SI::GFUN-NAME
#'"Function in SI package:
Syntax: (GFUN)

ECL/CLOS specific.
Returns the name of the GFUN generic function object.
"
SI::GFUN-NAME-SET
#'"Function in SI package:
Syntax: (GFUN NAME)

ECL/CLOS specific.
Sets to NAME the name of the GFUN generic function object.
"
SI::GFUN-SPEC-HOW-REF
#'"Function in SI package:
Syntax: (GFUN INDEX)

ECL/CLOS specific.
Returns the INDEX-th element of specialization list associated  with the
GFUN generic function object. The first element has INDEX equal to zero.
"
SI::GFUN-SPEC-HOW-SET
#'"Function in SI package:
Syntax: (GFUN INDEX SPECIALIZER)

ECL/CLOS specific.
Sets to SPECIALIZER the INDEX-th element of specialization list associated
with the GFUN generic function object. The first element has INDEX
equal to zero.
"
SI::GFUNP
#'"Function in SI package:
Syntax: (OBJECT)

ECL/CLOS specific.
Returns T if OBJECT is of gfun type.
"
GO
#'"Special Form in COMMON-LISP package:
Syntax: (go tag)

Jumps to TAG.  See TAGBODY.
"
GRAPHIC-CHAR-P
#'"Function in COMMON-LISP package:
Syntax: (CHAR)

Returns T if CHAR is a printing character, i.e., a standard character other
than #\\Newline.  Returns NIL otherwise.
"
HASH-TABLE
(TYPE "
A hash-table is a table used to map from objects to objects efficiently by the
hashing technique.  A hash-table is notated as
	#<hash-table n>
where N is actually a number that identifies the hash-table.")
HASH-TABLE-COUNT
#'"Function in COMMON-LISP package:
Syntax: (HASH-TABLE)

Returns the number of entries in HASH-TABLE.
"
HASH-TABLE-P
#'"Function in COMMON-LISP package:
Syntax: (X)

Returns T if X is a hash-table object; NIL otherwise.
"
SI::HELP
#'"Args: (&optional symbol)
ECL specific.
Prints the documentation associated with SYMBOL.  With no args, prints the
greeting message to ECL beginners.

Welcome to ECL. Here are the few functions you should learn first.

	(HELP symbol) prints the online documentation associated with the
	symbol.  For example, (HELP 'CONS) will print the useful information
	about the CONS function, the CONS data type, and so on.

	(HELP* string) prints the online documentation associated with those
	symbols whose print-names have the string as substring.  For example,
	(HELP* \"PROG\") will print the documentation of the symbols such as
	PROG, PROGN, and MULTIPLE-VALUE-PROG1.

	(QUIT) ends the current ECL session.

For the precise language specification, refer to Guy Steele's \"Common Lisp,
the Language\" and our \"ECL Manual\".  \"ECL Dictionary\", the hard-copied
version of ECL online documentation, will be useful as a handbook.

Good luck!
"
SI::HELP*
#'"Args: (string &optional (package-spec 'lisp))
ECL specific.
Prints the documentation associated with those symbols in the specified
package whose print names contain STRING as substring.  STRING may be a
symbol, in which case the print-name of that symbol is used.  If PACKAGE is
NIL, then all packages are searched."
HOST-NAMESTRING
#'"Function in COMMON-LISP package:
Syntax: (FILESPEC)

Returns as a string the host part of the pathname specified by FILESPEC.
FILESPEC may be a symbol, a string, a pathname, or a file stream.
"
IDENTITY
#'"Function in COMMON-LISP package:
Syntax: (X)

Returns X.
"
IF
#'"Special Form in COMMON-LISP package:
Syntax: (if test form1 [form2])

If TEST evaluates to non-NIL, then evaluates FORM1 and returns all values.
Otherwise, evaluates FORM2 (which defaults to NIL) and returns all values.
"
SI:IHS-FUN
#'"Function in SI package:
Syntax: (N)

ECL specific.
Returns the function value of the N-th entity in the invocation history stack.
"
IMAGPART
#'"Function in COMMON-LISP package:
Syntax: (NUMBER)

Returns the imagpart of NUMBER if it is a complex.  Otherwise, returns zero of
the same type as NUMBER.
"
IMPORT
#'"Function in COMMON-LISP package:
Syntax: (SYMBOL &OPTIONAL (PACKAGE *PACKAGE*))

Registers SYMBOL to PACKAGE as an internal symbol.  Does nothing if SYMBOL is
already registered in PACKAGE.  SYMBOL may be a list of symbols.
"
IN-PACKAGE
#'"Function in COMMON-LISP package:
Syntax: (PACKAGE-NAME &KEY (NICKNAMES NIL) (USE '(LISP)))

Makes the package named PACKAGE-NAME as the current package.  If such a
package does not exist, then creates one by passing all args to MAKE-PACKAGE.
Otherwise, adds the specified nicknames and packages to the nickname list and
use list of the package.  NICKNAMES must be a list consisting of strings and
symbols.  USE must be a list consisting of package objects and package names
(either string or symbol).
"
INCF
#'"Syntax: (incf place [form])
Increments the value of PLACE by the value of FORM.  FORM defaults to 1."
INPUT-STREAM-P
#'"Function in COMMON-LISP package:
Syntax: (STREAM)

Returns T if STREAM can handle input operations; NIL otherwise.
"
INSPECT
#'"Args: (object)
Shows the information about OBJECT interactively.  See the ECL Report for the
inspect commands, or type '?' to the inspector."
SI:INSTANCE-CLASS
#'"Function in SI package:
Syntax: (INSTANCE)

ECL/CLOS specific.
Returns the class of which the given INSTANCE is an instance.
"
SI:INSTANCE-CLASS-SET
#'"Function in SI package:
Syntax: (INSTANCE CLASS)

ECL/CLOS specific.
Makes INSTANCE an instance of CLASS class.
"
SI:INSTANCE-REF
#'"Function in SI package:
Syntax: (INSTANCE INDEX)

ECL/CLOS specific.
Returns the value of the INDEX-th slot of INSTANCE. The first slot has
INDEX equal to zero.
"
SI:INSTANCE-SET
#'"Function in SI package:
Syntax: (INSTANCE INDEX VALUE)

ECL/CLOS specific.
Sets to VALUE the value of INDEX-th slot of INSTANCE. The first slot has
INDEX equal to zero.
"
SI:INSTANCEP
#'"Function in SI package:
Syntax: (OBJECT)

ECL/CLOS specific.
Returns T if OBJECT is of instance type.
"
SI::INT-CHAR
#'"Function in SI package:
Syntax: (INTEGER)

Equivalent to CODE-CHAR.
"
INTEGER
(TYPE "
An integer object represents an integer in mathematical sense.  An integer may
be a fixnum, or else it is a bignum.  Normally, an integer is notated in radix
10 (see *PRINT-BASE* and *READ-BASE*) as
	[sign] {digit}+
where DIGIT is a decimal digit ('0', ..., '9') and SIGN is either '+' or '-'.
Also, the following syntax is used to notate the radix explicitly.
	# radix {r | R} [sign] {digit}+
where RADIX is one of '2', '3', ..., '36' and DIGIT is a digit in radix RADIX:
	Digits in radix 2 are '0' and '1'
	Digits in radix 8 are '0', ..., '7'
	Digits in radix 16 are '0', ..., '9', 'a', ..., 'f', and 'A', ..., 'F'
The following syntax is also available for radix 2, 8, 10, and 16.
	# {b | B} [sign] {digit}+
	# {o | O} [sign] {digit}+
		  [sign] {digit}+ .
	# {x | X} [sign] {digit}+")
INTEGER-DECODE-FLOAT
#'"Function in COMMON-LISP package:
Syntax: (FLOAT)

Returns, as three values, the integer interpretation of significand F, the
exponent E, and the sign S of FLOAT, such that
	FLOAT = S * F * B^E
where B = (float-radix FLOAT).  F is a non-negative integer, E is an integer,
and S is either 1 or -1.
"
INTEGER-LENGTH
#'"Function in COMMON-LISP package:
Syntax: (INTEGER)

Returns the number of \"significant bits\" in the representation of INTEGER.
With positive arg, returns one plus the position of the most significant bit
that is 'on'.  With negative arg other than -1, returns one plus the position
of the most significant bit that is 'off'.  For 0 and -1, returns 0.
"
INTEGERP
#'"Function in COMMON-LISP package:
Syntax: (X)

Returns T if X is an integer; NIL otherwise.
"
INTERN
#'"Function in COMMON-LISP package:
Syntax: (STRING &OPTIONAL (PACKAGE *PACKAGE*))

Searches PACKAGE for a symbol whose print name is STRING.  If such a symbol is
found, returns the symbol and, as the second value, one of the keywords
:INTERNAL, :EXTERNAL, and :INHERITED.  Otherwise, creates and returns a new
symbol and, as the second value, returns NIL.
"
INTERNAL-TIME-UNITS-PER-SECOND
(VARIABLE "Constant in COMMON-LISP package:
Gives the time unit used by GET-INTERNAL-REAL-TIME and GET-INTERNAL-RUN-TIME.
1000 in ECL.
")
INTERSECTION
#'"Args: (list1 list2 &key (key #'identity) (test #'eql) test-not)
Returns a list consisting of those objects that are elements of both LIST1 and
LIST2."
ISQRT
#'"Args: (integer)
Returns the integer square root of INTEGER."
KEYWORD
(TYPE "
A keyword is a symbol in the keyword package.")
KEYWORDP
#'"Function in COMMON-LISP package:
Syntax: (X)

Returns T if X is a symbol that belongs to the KEYWORD package; NIL otherwise.
"
LABELS
#'"Special Form in COMMON-LISP package:
Syntax: (labels ({(name lambda-list {decl | doc}* {form}*)}*) . body)

Introduces local functions and evaluates BODY as a PROGN.  The scope of each
local function include the local function definitions.  Thus self- and mutual-
recursive local functions can be defined.  Doc-strings for local functions are
simply ignored.
"
LAMBDA-LIST-KEYWORDS
(VARIABLE "Constant in COMMON-LISP package:
List of all lambda-list keywords, including
	&optional	&rest		&key
	&allow-other-keys		&aux
	&whole		&environment	&body
")
LAMBDA-PARAMETERS-LIMIT
(VARIABLE "Constant in COMMON-LISP package:
The upper bound of the number of parameters specified by a lambda list.
Ignore this number; there is no such upper bound in ECL.
")
LAST
#'"Function in COMMON-LISP package:
Syntax: (LIST)

Returns the last cons that constitute LIST.  Returns NIL if LIST is NIL.
"
LCM
#'"Function in COMMON-LISP package:
Syntax: (INTEGER &REST MORE-INTEGERS)

Returns the least common multiple of the args.  Returns 0 if at least one of
the args is 0.
"
LDB
#'"Args: (bytespec integer)
Extracts a byte from INTEGER at the specified byte position, right-justifies
the byte, and returns the result as an integer."
LDB-TEST
#'"Args: (bytespec integer)
Returns T if at least one bit of the specified byte is 1; NIL otherwise."
LDIFF
#'"Function in COMMON-LISP package:
Syntax: (LIST X)

If X is a cons that constitutes LIST, then returns a new list consisting of
those elements of LIST that appear before X.  Otherwise, returns a copy of
LIST.
"
LEAST-NEGATIVE-DOUBLE-FLOAT
(VARIABLE "Constant in COMMON-LISP package:
Same as LEAST-NEGATIVE-LONG-FLOAT.
")
LEAST-NEGATIVE-LONG-FLOAT
(VARIABLE "Constant in COMMON-LISP package:
The negative long-float with the smallest absolute value.
")
LEAST-NEGATIVE-SHORT-FLOAT
(VARIABLE "Constant in COMMON-LISP package:
The negative short-float with the smallest absolute value.
")
LEAST-NEGATIVE-SINGLE-FLOAT
(VARIABLE "Constant in COMMON-LISP package:
Same as LEAST-NEGATIVE-LONG-FLOAT.
")
LEAST-POSITIVE-DOUBLE-FLOAT
(VARIABLE "Constant in COMMON-LISP package:
Same as LEAST-POSITIVE-LONG-FLOAT.
")
LEAST-POSITIVE-LONG-FLOAT
(VARIABLE "Constant in COMMON-LISP package:
The smallest positive long-float.
")
LEAST-POSITIVE-SHORT-FLOAT
(VARIABLE "Constant in COMMON-LISP package:
The smallest positive short-float.
")
LEAST-POSITIVE-SINGLE-FLOAT
(VARIABLE "Constant in COMMON-LISP package:
Same as LEAST-POSITIVE-LONG-FLOAT.
")
LENGTH
#'"Function in COMMON-LISP package:
Syntax: (SEQUENCE)

Returns the length of SEQUENCE.
"
LET
#'"Special Form in COMMON-LISP package:
Syntax: (let ({var | (var [init])}*) {decl}* {form}*)

Evaluates all INITs (which defaults to NIL), binds the value of each INIT to
the corresponding VAR, evaluates FORMs, and returns all values of the last
FORM.  Returns NIL if no FORM is given.
"
LET*
#'"Special Form in COMMON-LISP package:
Syntax: (let* ({var | (var [init])}*) {decl}* {form}*)

Evaluates INIT (which defaults to NIL) and binds the value to the
corresponding VAR, one by one for each pair of VAR and INIT.  Then evaluates
FORMs and returns all values of the last FORM.  Returns NIL if no FORM is
given.
"
LISP-IMPLEMENTATION-TYPE
#'"Args: ()
Returns the string \"ECL\"."
LISP-IMPLEMENTATION-VERSION
#'"Args:()
Returns the version of your ECL as a string."
LIST
(FUNCTION "Function in COMMON-LISP package:
Syntax: (&REST ARGS)

Returns a list of the args.
" TYPE "As a type specifier, LIST is used to specify the type consisting of NIL and
cons objects.  In our ordinary life with Lisp, however, a list is either NIL
or a cons whose cdr is a list, and is notated by its elements surrounded with
parentheses.
The backquote macro is sometimes useful to construct a complicated list
structure.  When evaluating `(...)
	,form embeds the value of FORM,
	,@form and ,.form embed all elements of the list value of FORM,
	and other things embed itself
into the structure at their position.  For example,
	`(a b ,c d e) expands to (list* 'a 'b c '(d e))
	`(a b ,@c d e) expands to (list* 'a 'b (append c '(d e)))
	`(a b ,.c d e) expands to (list* 'a 'b (nconc c '(d e)))")
LIST*
#'"Function in COMMON-LISP package:
Syntax: (ARG &REST MORE-ARGS)

With one arg, simply returns it.  With n args (n > 1), conses the first arg to
the LIST* of the rest of args.
"
LIST-ALL-PACKAGES
#'"Function in COMMON-LISP package:
Syntax: NIL

Returns a list of all packages.
"
LIST-LENGTH
#'"Function in COMMON-LISP package:
Syntax: (LIST)

Returns the length of LIST.  Returns NIL if LIST is circular.
"
LISTEN
#'"Function in COMMON-LISP package:
Syntax: (&OPTIONAL (STREAM *STANDARD-INPUT*))

Returns T if STREAM is ready to input a character from; NIL otherwise.  In
some versions of ECL, this function does not work correctly because the
underlying OS does not support such a mechanism.
"
LISTP
#'"Function in COMMON-LISP package:
Syntax: (X)

Returns T if X is either a cons or NIL.  Otherwise, returns NIL.
"
LOAD
#'"Function in COMMON-LISP package:
Syntax: (FILESPEC &KEY (VERBOSE *LOAD-VERBOSE*) (PRINT NIL) (IF-DOES-NOT-EXIST ERROR))

Loads the contents of the specified file into ECL.
If the filetype is not specified, ECL first tries to load the fasl file with
filetype \".fasl\", then tries to load the source file with filetype \".lsp\",
and then tries to load the source file with no filetype.
FILESPEC may be a symbol, a string, a pathname, or a file stream.  VERBOSE
specifies whether or not the loader prints a loading message.  PRINT specifies
whether or not the loader prints the values of the top-level forms.
IF-DOES-NOT-EXIST specifies the behavior of the loader when the specified file
is not found.  It may be :ERROR or NIL.
If the file was loaded successfully, returns the pathname of the file actually
loaded
"
LOAD-LOGICAL-PATHNAME-TRANSLATIONS
#'"Search for a logical pathname named host, if not already defined. If already
defined no attempt to find or load a definition is attempted and NIL is
returned. If host is not already defined, but definition is found and loaded
successfully, T is returned, else error."
LOCALLY
#'"Macro in COMMON-LISP package:
Syntax: (locally {decl}* {form}*)

Gives DECLs locally while evaluating FORMs, and returns all values of the last
FORM.  Returns NIL if no FORM is given.
"
LOG
#'"Function in COMMON-LISP package:
Syntax: (NUMBER1 &OPTIONAL NUMBER2)

With two args, returns the logarithm of NUMBER1 in base NUMBER2.  With one
arg, returns the natural logarithm of the arg.
"
LOGAND
#'"Function in COMMON-LISP package:
Syntax: (&REST INTEGERS)

Returns the bit-wise AND of the args.
"
LOGANDC1
#'"Function in COMMON-LISP package:
Syntax: (INTEGER1 INTEGER2)

Equivalent to (LOGAND (LOGNOT INTEGER1) INTEGER2).
"
LOGANDC2
#'"Function in COMMON-LISP package:
Syntax: (INTEGER1 INTEGER2)

Equivalent to (LOGAND INTEGER1 (LOGNOT INTEGER2)).
"
LOGBITP
#'"Function in COMMON-LISP package:
Syntax: (BIT-POSITION INTEGER)

Returns T if the specified bit of INTEGER is 1; NIL otherwise.  BIT-POSITION
must be a non-negative integer, with 0 representing the least significant bit.
"
LOGCOUNT
#'"Function in COMMON-LISP package:
Syntax: (INTEGER)

If INTEGER is negative, returns the number of 0 bits.  Otherwise, returns the
number of 1 bits.
"
LOGEQV
#'"Function in COMMON-LISP package:
Syntax: (&REST INTEGERS)

Returns the bit-wise EQUIVALENCE of the args.
"
LOGIOR
#'"Function in COMMON-LISP package:
Syntax: (&REST INTEGERS)

Returns the bit-wise INCLUSIVE OR of the args.
"
LOGNAND
#'"Function in COMMON-LISP package:
Syntax: (INTEGER1 INTEGER2)

Equivalent to (LOGNOT (LOGAND INTEGER1 INTEGER2)).
"
LOGNOR
#'"Function in COMMON-LISP package:
Syntax: (INTEGER1 INTEGER2)

Equivalent to (LOGNOT (LOGIOR INTEGER1 INTEGER2)).
"
LOGNOT
#'"Function in COMMON-LISP package:
Syntax: (INTEGER)

Returns the bit-wise logical NOT of the arg.
"
LOGORC1
#'"Function in COMMON-LISP package:
Syntax: (INTEGER1 INTEGER2)

Equivalent to (LOGIOR (LOGNOT INTEGER1) INTEGER2).
"
LOGORC2
#'"Function in COMMON-LISP package:
Syntax: (INTEGER1 INTEGER2)

Equivalent to (LOGIOR INTEGER1 (LOGNOT INTEGER2)).
"
LOGTEST
#'"Args: (integer1 integer2)
Equivalent to (NOT (ZEROP (LOGAND INTEGER1 INTEGER2)))."
LOGXOR
#'"Function in COMMON-LISP package:
Syntax: (&REST INTEGERS)

Returns the bit-wise EXCLUSIVE OR of the args.
"
LONG-FLOAT
(TYPE "
A long-float is a long-precision floating point number.")
LONG-FLOAT-EPSILON
(VARIABLE "The smallest postive long-float E that satisfies
	(not (= (float 1 E) (+ (float 1 E) E)))")
LONG-FLOAT-NEGATIVE-EPSILON
(VARIABLE "The smallest positive long-float E that satisfies
	(not (= (float 1 E) (- (float 1 E) E)))")
LONG-SITE-NAME
#'"Args: ()
Returns, as a string, the location of the machine on which ECL runs."
LOOP
#'"Syntax: (loop {form}*)
Establishes a NIL block and executes FORMs repeatedly.  The loop is normally
terminated by a non-local exit."
LOOP-FINISH
#'"Causes the iteration to terminate \"normally\", the same as implicit
termination by an iteration driving clause, or by use of WHILE or
UNTIL -- the epilogue code (if any) will be run, and any implicitly
collected result will be returned as the value of the LOOP."
LOWER-CASE-P
#'"Function in COMMON-LISP package:
Syntax: (CHAR)

Returns T if CHAR is a lower-case character; NIL otherwise.
"
MACHINE-INSTANCE
#'"Args: ()
Returns, as a string, the identifier of the machine on which ECL runs."
MACHINE-TYPE
#'"Args: ()
Returns, as a string, the type of the machine on which ECL runs."
MACHINE-VERSION
#'"Args: ()
Returns, as a string, the version of the machine on which ECL runs. Obtained from
uname(2) where available."
MACRO-FUNCTION
#'"Function in COMMON-LISP package:
Syntax: (SYMBOL)

Returns the expansion function of the global macro named SYMBOL.  Returns NIL
if no such macro exists.  The expansion function receives a macro form and an
environment, and returns the expanded form.
"
MACROEXPAND
#'"Function in COMMON-LISP package:
Syntax: (FORM &OPTIONAL (ENV NIL))

If FORM is a macro form, then expands it repeatedly until the result is not a
macro any more, and returns the result as the first value and T as the second
value.  Otherwise, returns FORM and NIL as two values.
"
MACROEXPAND-1
#'"Function in COMMON-LISP package:
Syntax: (FORM &OPTIONAL (ENV NIL))

If FORM is a macro form, then expands it once and returns the result as the
first value and T as the second value.  Otherwise, returns FORM and NIL as two
values.
"
MACROLET
#'"Special Form in COMMON-LISP package:
Syntax: (macrolet ({(name defmacro-lambda-list {decl | doc}* {form}*)}*)
          . body)

Introduces local macros and evaluates BODY as a PROGN.  See DEFMACRO for the
complete syntax of defmacro-lambda-list.  Doc-strings for local macros are
simply ignored.
"
MAKE-ARRAY
#'"Args: (dimensions &key (element-type t) initial-element (initial-contents nil)
		    (adjustable nil) (fill-pointer nil) (displaced-to nil)
		    (displaced-index-offset 0) (static nil))
Creates an array of the specified DIMENSIONS.  DIMENSIONS is a list of
non-negative integers each representing the length of the corresponding
dimension.  It may be an integer for vectors, i.e., one-dimensional arrays.
ELEMENT-TYPE specifies the type of array elements.  INITIAL-ELEMENT specifies
the initial value for all elements.  Its default value depends on ELEMENT-
TYPE.  INITIAL-CONTENTS specifies each element in terms of sequences.
ADJUSTABLE specifies whether or not the array is adjustable (see ADJUST-
ARRAY).  FILL-POINTER is meaningful only for vectors.  It specifies whether
the vector has fill-pointer or not, and if it has, the initial value of the
fill-pointer.  Possible values are NIL (no fill-pointer), T (the length of the
vector), or an integer.  See VECTOR-PUSH and VECTOR-POP.  DISPLACED-TO, if
non-NIL, must be an array and specifies that the new array is displaced to the
given array.  DISPLACED-INDEX-OFFSET is meaningful only when DISPLACED-TO is
non-NIL and specifies that the reference to the I-th element of the new array
in raw-major indexing is actually the reference to the (I + DISPLACED-INDEX-
OFFSET)th element of the given array.If the STATIC argument is supplied
with a non-nil value, then the body of the array is allocated as a
contiguous block."
MAKE-BROADCAST-STREAM
#'"Function in COMMON-LISP package:
Syntax: (&REST STREAMS)

Creates and returns a broadcast stream.  Outputs to this stream are output to
all STREAMs.  A broadcast stream is notated as
	#<broadcast stream n>
where N is a number that identify the stream.
"
SI::MAKE-CHAR
#'"Function in SI package:
Syntax: (CHAR &OPTIONAL (BITS 0) (FONT 0))

Returns a character object with the same code as CHAR and with the specified
BITS and FONT attributes.  Returns NIL if no such character exists.
"
MAKE-CONCATENATED-STREAM
#'"Function in COMMON-LISP package:
Syntax: (&REST STREAMS)

Creates and returns a concatenated stream.  Inputs from this stream are first
obtained from the first STREAM.  When the end of the first STREAM is reached,
then inputs are obtained from the second STREAM.  And so forth.
A concatenated stream is notated as
	#<concatenated stream n>
where N is a number that identifies the stream.
"
MAKE-DISPATCH-MACRO-CHARACTER
#'"Function in COMMON-LISP package:
Syntax: (CHAR &OPTIONAL (NON-TERMINATING-P NIL) (READTABLE *READTABLE*))

Register CHAR as a dispatch macro character in READTABLE.  NON-TERMINATING-P
specifies whether CHAR is non-terminating (see READTABLE).
"
MAKE-ECHO-STREAM
#'"Function in COMMON-LISP package:
Syntax: (STREAM1 STREAM2)

Creates and returns an echo stream.  Inputs from this stream are obtained from
STREAM1 and outputs to this stream are output to STREAM2.  In addition, all
inputs from STREAM1 are output to STREAM2.
An echo stream is notated as
	#<echo stream n>
where N is a number that identifies the stream.
"
MAKE-HASH-TABLE
#'"Function in COMMON-LISP package:
Syntax: (&KEY (TEST 'EQL) (SIZE 1024) (REHASH-SIZE 1.5) (REHASH-THRESHOLD 0.69999999))

Creates and returns a hash-table.
TEST specifies which predicate should be used to access hash-table entries.
It must be EQ, EQL, or EQUAL.  SIZE specifies the number of entries in the
hash-table.  REHASH-SIZE, if an integer, specifies how many entries should be
added when the hash-table becomes 'almost full'.  REHASH-SIZE, if a float,
specifies the ratio of the new size and the old size.  REHASH-THRESHOLD
specifies when to expand the hash-table.  If an integer, the hash-table is
expanded when REHASH-THRESHOLD / REHASH-SIZE entries have been used.  If a
float, the hash-table is expanded when REHASH-THRESHOLD times the whole
entries have been used.
"
MAKE-LIST
#'"Function in COMMON-LISP package:
Syntax: (LENGTH &KEY (INITIAL-ELEMENT NIL))

Creates and returns a list of the specified LENGTH, whose elements are all the
value of INITIAL-ELEMENT.
"
MAKE-PACKAGE
#'"Function in COMMON-LISP package:
Syntax: (PACKAGE-NAME &KEY (NICKNAMES NIL) (USE '(LISP)))

Creates and returns a new package named PACKAGE-NAME.  PACKAGE-NAME must be a
string or a symbol.  The print name is used if PACKAGE-NAME is a symbol.
NICKNAMES gives the nicknames of the package.  It must be a list of strings
and symbols.  USE specifies the packages used by the created package.  It must
be a list of package objects, strings, and symbols.
"
MAKE-PATHNAME
#'"Function in COMMON-LISP package:
Syntax: (&KEY (DEFAULTS (PARSE-NAMESTRING \"\" (PATHNAME-HOST *DEFAULT-PATHNAME-DEFAULTS*))) (HOST (PATHNAME-HOST DEFAULTS)) (DEVICE (PATHNAME-DEVICE DEFAULTS)) (DIRECTORY (PATHNAME-DIRECTORY DEFAULTS)) (NAME (PATHNAME-NAME DEFAULTS)) (TYPE (PATHNAME-TYPE DEFAULTS)) (VERSION (PATHNAME-VERSION DEFAULTS)))

Creates a pathname object with the slot values specified by HOST, DEVICE,
DIRECTORY, NAME, TYPE, and VERSION.
"
SI:MAKE-PIPE
#'"Function in SI package:
Syntax: NIL
Creates a pipe in the form of a two-way stream that can be used for
interprocess and interthread communication.
"
MAKE-RANDOM-STATE
#'"Function in COMMON-LISP package:
Syntax: (&OPTIONAL (RANDOM-STATE NIL))

Creates and returns a random-state object.  If RANDOM-STATE is NIL, copies the
value of *RANDOM-STATE*.  If RANDOM-STATE is a random-state, copies it.  If
RANDOM-STATE is T, creates a random-state randomly.
"
MAKE-SEQUENCE
#'"Args: (type length &key initial-element)
Creates and returns a sequence of the given TYPE and LENGTH.  If INITIAL-
ELEMENT is given, then it becomes the elements of the created sequence.  The
default value of INITIAL-ELEMENT depends on TYPE."
MAKE-STRING
#'"Function in COMMON-LISP package:
Syntax: (LENGTH &KEY (INITIAL-ELEMENT  ))

Creates and returns a new string of the given LENGTH, whose elements are all
INITIAL-ELEMENT.
"
MAKE-STRING-INPUT-STREAM
#'"Function in COMMON-LISP package:
Syntax: (STRING &OPTIONAL (START 0) (END (LENGTH STRING)))

Creates and returns a string-input stream.  Inputs from this stream are
obtained form STRING.  A string-input stream is notated as
	#<string-input stream from s>
where S is a string.
"
MAKE-STRING-OUTPUT-STREAM
#'"Function in COMMON-LISP package:
Syntax: NIL

Creates and returns a string-output stream.  Outputs to this stream are
obtained as a string by GET-OUTPUT-STREAM-STRING.  A string-output stream
is notated as
	#<string-output stream n>
where N is a number that identifies the stream.
"
SI:MAKE-STRING-OUTPUT-STREAM-FROM-STRING
#'"Function in SI package:
Syntax: STRING
)
ECL specific.
Creates and returns a string-output-stream to STRING.  STRING must have a
fill-pointer.
"
MAKE-SYMBOL
#'"Function in COMMON-LISP package:
Syntax: (STRING)

Creates and returns a new uninterned symbol whose print name is STRING.
"
MAKE-SYNONYM-STREAM
#'"Function in COMMON-LISP package:
Syntax: (SYMBOL)

Creates and returns a synonym stream to SYMBOL.  Inputs from this stream are
obtained from, and outputs to this stream are sent to the stream that is the
value of the global variable named SYMBOL.  A synonym stream is notated as
	#<synonym stream to s>
where S is a symbol.
"
MAKE-TWO-WAY-STREAM
#'"Function in COMMON-LISP package:
Syntax: (STREAM1 STREAM2)

Creates and returns a two-way stream.  Inputs from this stream are obtained
from STREAM1 and outputs to this stream are sent to STREAM2.  A two-way stream
is notated as
	#<two-way stream n>
where N is a number that identifies the stream.
"
MAKUNBOUND
#'"Function in COMMON-LISP package:
Syntax: (SYMBOL)

Makes the global variable named SYMBOL have no value.  Returns SYMBOL.
"
MAP
#'"Args: (type function sequence &rest more-sequences)
Creates and returns a sequence of TYPE with K elements, with the N-th element
being the value of applying FUNCTION to the N-th elements of the given
SEQUENCEs, where K is the minimum length of the given SEQUENCEs."
MAP-INTO
#'"Fills the output sequence with the values returned by applying FUNCTION to the
elements of the given sequences. The i-th element of RESULT-SEQUENCE is the output
of applying FUNCTION to the i-th element of each of the sequences. The map routine
stops when it reaches the end of one of the given sequences."
MAPC
#'"Function in COMMON-LISP package:
Syntax: (FUNCTION LIST &REST MORE-LISTS)

For each N (0 <= N < K), applies FUNCTION to the N-th elements of the given
LISTs, where K is the minimum length of the given LISTs.  Returns the first
LIST.
"
MAPCAN
#'"Function in COMMON-LISP package:
Syntax: (FUNCTION LIST &REST MORE-LISTS)

For each N (0 <= N < K), applies FUNCTION to the N-th elements of the given
LISTs, where K is the minimum length of the given LISTs.  Nconcs the values,
one for each call to FUNCTION, and returns the result.
"
MAPCAR
#'"Function in COMMON-LISP package:
Syntax: (FUNCTION LIST &REST MORE-LISTS)

Creates and returns a list of K elements, with the N-th element being the
value of applying FUNCTION to the N-th elements of the given LISTs, where K
is the minimum length of the given LISTs.
"
MAPCON
#'"Function in COMMON-LISP package:
Syntax: (FUNCTION LIST &REST MORE-LISTS)

For each N (0 <= N < K), applies FUNCTION to the N-th cdrs of the given LISTs,
where K is the minimum length of the given LISTs.  Nconcs the values, one for
each call to FUNCTION, and returns the result.
"
MAPHASH
#'"Function in COMMON-LISP package:
Syntax: #'HASH-TABLE

For each entry of HASH-TABLE, applies FUNCTION to the key and the value of the
entry.  Returns NIL.
"
MAPL
#'"Function in COMMON-LISP package:
Syntax: (FUNCTION LIST &REST MORE-LISTS)

For each N (0 <= N < K), applies FUNCTION to the N-th cdrs of the given LISTs,
where K is the minimum length of the given LISTs.  Returns the first LIST.
"
MAPLIST
#'"Function in COMMON-LISP package:
Syntax: (FUNCTION LIST &REST MORE-LISTS)

Creates and returns a list of K elements, with the N-th element being the
value of applying FUNCTION to the N-th cdrs of the given LISTs, where K is the
minimum length of the given LISTs.
"
MASK-FIELD
#'"Args: (bytespec integer)
Extracts the specified byte from INTEGER and returns the result as an integer."
MAX
#'"Function in COMMON-LISP package:
Syntax: (NUMBER &REST MORE-NUMBERS)

Returns the largest arg.  The args must be non-complex numbers.
"
SI::MAXIMUM-ALLOCATABLE-PAGES
#'"Function in SI package:
Syntax: (TYPE)

ECL specific.
Returns the current maximum number of pages for the type class of the ECL
implementation type TYPE.
"
MEMBER
#'"Function in COMMON-LISP package:
Syntax: (ITEM LIST &KEY (KEY '#'IDENTITY) (TEST '#'EQL) TEST-NOT)

Searches LIST for an element that is equal to ITEM in the sense of the TEST.
If found, returns the sublist of LIST that begins with the element.
Otherwise, returns NIL.
"
MEMBER-IF
#'"Searches LIST for an element that satisfies TEST.  If found, returns the
sublist of LIST that begins with the element.  If not found, returns NIL."
MEMBER-IF-NOT
#'"Searches LIST for an element that does not satisfy TEST.  If found, returns
the sublist of LIST that begins with the element.  If not found, returns NIL."
MERGE
#'"Args: (type sequence1 sequence2 test &key key)
Merges two sequences in the way specified by TEST and returns the result as a
sequence of TYPE.  Both SEQUENCEs may be destroyed.  If both SEQUENCE1 and
SEQUENCE2 are sorted in the sense of TEST, then the result is also sorted in
the sense of TEST."
MERGE-PATHNAMES
#'"Function in COMMON-LISP package:
Syntax: (FILESPEC &OPTIONAL (DEFAULTS *DEFAULT-PATHNAME-DEFAULTS*) DEFAULT-VERSION)

Fills in unspecified slots of the pathname specified by FILESPEC from the
pathname specified by DEFAULTS, and returns the result pathname.  DEFAULT-
VERSION is simply ignored in ECL.  FILESPEC and DEFAULTS may be a symbol, a
string, a pathname, or a file stream.
"
MIN
#'"Function in COMMON-LISP package:
Syntax: (NUMBER &REST MORE-NUMBERS)

Returns the smallest arg.  The args must be non-complex numbers.
"
MINUSP
#'"Function in COMMON-LISP package:
Syntax: (NUMBER)

Returns T if NUMBER is negative; NIL otherwise.
"
MISMATCH
#'"Args: (sequence1 sequence2
       &key key (test '#'eql) test-not
            (start1 0) (end1 (length sequence1))
            (start2 0) (end2 (length sequence2))
            (from-end nil))
Compares element-wise the specified subsequences of SEQUENCE1 and SEQUENCE2.
Returns NIL if they are of the same length and they have the same elements in
the sense of TEST.  Otherwise, returns the index of SEQUENCE1 to the first
element that does not match."
MOD
#'"Function in COMMON-LISP package:
Syntax: (NUMBER DIVISOR)

Returns the second result of (FLOOR NUMBER DIVISOR), i.e. the value of
	(- NUMBER (* (FLOOR NUMBER DIVISOR) DIVISOR))
"
MOST-NEGATIVE-DOUBLE-FLOAT
(VARIABLE "Constant in COMMON-LISP package:
Same as MOST-NEGATIVE-LONG-FLOAT.
")
MOST-NEGATIVE-FIXNUM
(VARIABLE "Constant in COMMON-LISP package:
The negative fixnum with the largest absolute value.  - 2^29 in ECL.
")
MOST-NEGATIVE-LONG-FLOAT
(VARIABLE "Constant in COMMON-LISP package:
The long-float with the largest absolute value.
")
MOST-NEGATIVE-SHORT-FLOAT
(VARIABLE "Constant in COMMON-LISP package:
The short-float with the largest absolute value.
")
MOST-NEGATIVE-SINGLE-FLOAT
(VARIABLE "Constant in COMMON-LISP package:
Same as MOST-NEGATIVE-LONG-FLOAT.
")
MOST-POSITIVE-DOUBLE-FLOAT
(VARIABLE "Constant in COMMON-LISP package:
Same as MOST-POSITIVE-LONG-FLOAT.
")
MOST-POSITIVE-FIXNUM
(VARIABLE "Constant in COMMON-LISP package:
The largest positive fixnum.  2^29 - 1 in ECL.
")
MOST-POSITIVE-LONG-FLOAT
(VARIABLE "Constant in COMMON-LISP package:
The largest positive long-float.
")
MOST-POSITIVE-SHORT-FLOAT
(VARIABLE "Constant in COMMON-LISP package:
The largest positive short-float.
")
MOST-POSITIVE-SINGLE-FLOAT
(VARIABLE "Constant in COMMON-LISP package:
Same as MOST-POSITIVE-LONG-FLOAT.
")
MULTIPLE-VALUE-BIND
#'"Syntax: (multiple-value-bind ({var}*) init {decl}* {form}*)

Evaluates INIT and binds the N-th VAR to the N-th value of INIT or, if INIT
returns less than N values, to NIL.  Then evaluates FORMs, and returns all
values of the last FORM.  If no FORM is given, returns NIL."
MULTIPLE-VALUE-CALL
#'"Special Form in COMMON-LISP package:
Syntax: (multiple-value-call function-form {form}*)

Evaluates FUNCTION-FORM, whose value must be a function.  Then evaluates FORMs
and applies the function to all values of FORMs.  Unlike FUNCALL, all values
of each FORM are used as arguments.  Returns all values of the function.
"
MULTIPLE-VALUE-LIST
#'"Evaluates FORM and returns a list of all values FORM returns."
MULTIPLE-VALUE-PROG1
#'"Special Form in COMMON-LISP package:
Syntax: (multiple-value-prog1 first-form {form}*)

Evaluates FIRST-FORM, saves all values it returns, and then evaluates FORMs.
Returns all the saved values of FIRST-FORM.
"
MULTIPLE-VALUE-SETQ
#'"Syntax: (multiple-value-setq {var}* form)

Evaluates FORM and binds the N-th VAR to the N-th value of FORM or, if FORM
returns less than N values, to NIL.  Returns the first value of FORM or, if
FORM returns no value, NIL."
MULTIPLE-VALUES-LIMIT
(VARIABLE "Constant in COMMON-LISP package:
The upper bound on the number of values that a function can return.  Actually,
however, there is no such upper bound in ECL.
")
NAME-CHAR
#'"Function in COMMON-LISP package:
Syntax: (NAME)

Given an argument acceptable to string,
Returns a character object with the specified character name (see CHARACTER).
Returns NIL if no such character object exists.  NAME is typically a string
but may be any object that can be coerced to string.
"
NAMESTRING
#'"Function in COMMON-LISP package:
Syntax: (FILESPEC)

Returns as a string all slots of the pathname specified by FILESPEC.  FILESPEC
may be a symbol, a string, a pathname, or a file stream.
"
NBUTLAST
#'"Function in COMMON-LISP package:
Syntax: (LIST &OPTIONAL (N 1))

Destructive BUTLAST.  LIST may be destroyed.
"
NCONC
#'"Function in COMMON-LISP package:
Syntax: (&REST LISTS)

Destructive APPEND.  The args except for the last may be destroyed.
"
CLOS::NEED-TO-MAKE-LOAD-FORM-P
#'"Return T if the object cannot be externalized using the lisp
printer and we should rather use MAKE-LOAD-FORM."
NIL
(VARIABLE "Constant in COMMON-LISP package:
The value of NIL is NIL.
" TYPE "
The type NIL is a subtype of every type.  No object belongs to this type.")
NINTERSECTION
#'"Args: (list1 list2 &key (key #'identity) (test #'eql) test-not)
Destructive INTERSECTION.  Only LIST1 may be destroyed."
NINTH
#'"Function in COMMON-LISP package:
Syntax: (X)

Equivalent to (CAR (CDDDDR (CDDDDR X))).
"
NOT
#'"Function in COMMON-LISP package:
Syntax: (X)

Returns T if X is NIL; NIL otherwise.
"
NOTANY
#'"Args: (predicate sequence &rest more-sequences)
Returns T if none of the elements in SEQUENCEs satisfies PREDICATE; NIL
otherwise."
NOTEVERY
#'"Args: (predicate sequence &rest more-sequences)
Returns T if at least one of the elements in SEQUENCEs does not satisfy
PREDICATE; NIL otherwise."
NRECONC
#'"Function in COMMON-LISP package:
Syntax: (X Y)

Equivalent to (NCONC (NREVERSE X) Y).
"
NREVERSE
#'"Function in COMMON-LISP package:
Syntax: (SEQUENCE)

Destructive REVERSE.  The arg may be destroyed.
"
NSET-DIFFERENCE
#'"Args: (list1 list2 &key (key #'identity) (test #'eql) test-not)
Destructive SET-DIFFERENCE.  Only LIST1 may be destroyed."
NSET-EXCLUSIVE-OR
#'"Args: (list1 list2 &key (key #'identity) (test #'eql) test-not)
Destructive SET-EXCLUSIVE-OR.  Both LIST1 and LIST2 may be destroyed."
NSTRING-CAPITALIZE
#'"Function in COMMON-LISP package:
Syntax: (STRING &KEY (START 0) (END (LENGTH STRING)))

Destructive STRING-CAPITALIZE.  STRING may be destroyed.
"
NSTRING-DOWNCASE
#'"Function in COMMON-LISP package:
Syntax: (STRING &KEY (START 0) (END (LENGTH STRING)))

Destructive STRING-DOWNCASE.  STRING may be destroyed.
"
NSTRING-UPCASE
#'"Function in COMMON-LISP package:
Syntax: (STRING &KEY (START 0) (END (LENGTH STRING)))

Destructive STRING-UPCASE.  STRING may be destroyed.
"
NSUBLIS
#'"Function in COMMON-LISP package:
Syntax: (ALIST TREE &KEY (KEY '#'IDENTITY) (TEST '#'EQL) TEST-NOT)

Destructive SUBLIS.  TREE may be destroyed.
"
NSUBST
#'"Function in COMMON-LISP package:
Syntax: (NEW OLD TREE &KEY (KEY '#'IDENTITY) (TEST '#'EQL) TEST-NOT)

Destructive SUBST.  TREE may be destroyed.
"
NSUBST-IF
#'"Destructive SUBST-IF. TREE may be modified."
NSUBST-IF-NOT
#'"Destructive SUBST-IF-NOT. TREE may be modified."
NSUBSTITUTE
#'"Function in COMMON-LISP package:
Syntax: (NEW OLD SEQUENCE &KEY (KEY '#'IDENTITY) (TEST '#'EQL) TEST-NOT (START 0) (END (LENGTH SEQUENCE)) (COUNT MOST-POSITIVE-FIXNUM) (FROM-END NIL))

Destructive SUBSTITUTE.  SEQUENCE may be destroyed.
"
NSUBSTITUTE-IF
#'"Function in COMMON-LISP package:
Syntax: (NEW TEST SEQUENCE &KEY (KEY '#'IDENTITY) (START 0) (END (LENGTH SEQUENCE)) (COUNT MOST-POSITIVE-FIXNUM) (FROM-END NIL))

Destructive SUBSTITUTE-IF.  SEQUENCE may be destroyed.
"
NSUBSTITUTE-IF-NOT
#'"Function in COMMON-LISP package:
Syntax: (NEW TEST SEQUENCE &KEY (KEY '#'IDENTITY) (START 0) (END (LENGTH SEQUENCE)) (COUNT MOST-POSITIVE-FIXNUM) (FROM-END NIL))

Destructive SUBSTITUTE-IF-NOT.  SEQUENCE may be destroyed.
"
NTH
#'"Function in COMMON-LISP package:
Syntax: (N LIST)

Returns the N-th element of LIST, the first element of LIST being the zeroth.
Returns NIL if the length of LIST is less than N.  N must be a non-negative
integer.
"
NTHCDR
#'"Function in COMMON-LISP package:
Syntax: (N LIST)

Returns the N-th cdr of LIST.  N must be a non-negative integer.
"
NULL
(FUNCTION "Function in COMMON-LISP package:
Syntax: (X)

Returns T if X is NIL; NIL otherwise.
" TYPE "The type to which only NIL belongs.")
NUMBER
(TYPE "
A number is an integer, a ratio, a float, or a complex number.  Integers and
ratios are collectively called rationals.")
NUMBERP
#'"Function in COMMON-LISP package:
Syntax: (X)

Returns T if X is a number; NIL otherwise.
"
NUMERATOR
#'"Function in COMMON-LISP package:
Syntax: (RATIONAL)

Returns the numerator of RATIONAL as an integer, if RATIONAL is a ratio.
Returns RATIONAL if it is an integer.
"
NUNION
#'"Args: (list1 list2 &key (key #'identity) (test #'eql) test-not)
Destructive UNION.  Both LIST1 and LIST2 may be destroyed."
ODDP
#'"Function in COMMON-LISP package:
Syntax: (INTEGER)

Returns T if INTEGER is an odd number; NIL otherwise.
"
SI::ONCE-ONLY
#'"Once-Only ({(Var Value-Expression)}*) Form*
  Create a Let* which evaluates each Value-Expression, binding a temporary
  variable to the result, and wrapping the Let* around the result of the
  evaluation of Body.  Within the body, each Var is bound to the corresponding
  temporary variable."
OPEN
#'"Function in COMMON-LISP package:
Syntax: (FILESPEC &KEY (DIRECTION INPUT) ELEMENT-TYPE IF-EXISTS IF-DOES-NOT-EXIST)

Opens the specified file and returns a file stream to/from the file.  FILESPEC
may be a symbol, a string, a pathname, or a file stream.  DIRECTION may be
:INPUT, :OUTPUT, :IO, or :PROBE.  ELEMENT-TYPE is simply ignored in ECL.  IF-
EXISTS specifies what to do when DIRECTION is either :OUTPUT or :IO and the
specified file exists already.  It may be :ERROR (the default), :NEW-VERSION,
:RENAME, :RENAME-AND-DELETE, :OVERWRITE, :APPEND, :SUPERSEDE, or NIL.  IF-
DOES-NOT-EXIST specifies what to do when the specified file does not exists.
It may be :ERROR (the default when DIRECTION is :INPUT), :CREATE (the default
when DIRECTION is either :OUTPUT or :IO), or NIL.
File streams are notated in one of the following ways:
	#<input stream f>
	#<output stream f>
	#<io stream f>
	#<probe stream f>
where F is the file name.
"
OR
#'"Macro in COMMON-LISP package:
Syntax: (or {form}*)

Evaluates FORMs in order from left to right.  If any FORM evaluates to non-
NIL, quits and returns that (single) value.  If the last FORM is reached,
returns whatever values it returns.
"
SI::ORDINAL-ONES
(VARIABLE "Table of ordinal ones-place digits in English")
SI::ORDINAL-TENS
(VARIABLE "Table of ordinal tens-place digits in English")
OUTPUT-STREAM-P
#'"Function in COMMON-LISP package:
Syntax: (STREAM)

Returns T if STREAM can handle output operations; NIL otherwise.
"
PACKAGE
(TYPE "
A package object serves as a name space of symbols.  A package is notated as
#<s package> where S is actually the name of the package.  ECL provides five
built-in packages:
	lisp	 standard symbols of Common Lisp.
	user	 the package that the user uses by default.
	keyword	 keyword symbols.
	system	 system internal symbols.  Has nicknames SYS and SI.
	compiler system internal symbols for the ECL compiler.")
PACKAGE-NAME
#'"Function in COMMON-LISP package:
Syntax: (PACKAGE)

Returns the name of PACKAGE as a string.
"
PACKAGE-NICKNAMES
#'"Function in COMMON-LISP package:
Syntax: (PACKAGE)

Returns the nicknames of PACKAGE as a list of strings.
"
PACKAGE-SHADOWING-SYMBOLS
#'"Function in COMMON-LISP package:
Syntax: (PACKAGE)

Returns, as a list, those symbols in PACKAGE that are shadowing symbols in
other packages.
"
PACKAGE-USE-LIST
#'"Function in COMMON-LISP package:
Syntax: (PACKAGE)

Returns, as a list, those packages that PACKAGE uses.
"
PACKAGE-USED-BY-LIST
#'"Function in COMMON-LISP package:
Syntax: (PACKAGE)

Returns, as a list, those packages that use PACKAGE.
"
PACKAGEP
#'"Function in COMMON-LISP package:
Syntax: (X)

Returns T if X is a package object; NIL otherwise.
"
PAIRLIS
#'"Function in COMMON-LISP package:
Syntax: (KEYS ITEMS &OPTIONAL (ALIST NIL))

Conses each KEY and the corresponding ITEM, adds them to ALIST, and returns
the result.  KEYS and ITEMS must be of the same length.
"
PARSE-INTEGER
#'"Function in COMMON-LISP package:
Syntax: (STRING &KEY (START 0) (END (LENGTH STRING)) (RADIX 10) (JUNK-ALLOWED NIL))

Parses STRING for an integer and returns it.  As the second value, returns the
index to the character next to the last character that is parsed.  If JUNK-
ALLOWED is non-NIL, ignores white spaces before and after the number
representation in STRING and returns NIL even if STRING is not parsed
successfully.
"
PARSE-NAMESTRING
#'"Function in COMMON-LISP package:
Syntax: (STRING &OPTIONAL HOST DEFAULTS &KEY (START 0) END (JUNK-ALLOWED NIL))

Parses STRING and returns a pathname.  As the second value, returns the index
to the character next to the last character that has been parsed.  STRING is
usually a string object but it may be a symbol, a pathname, or a file stream.
START and END are meaningful only when STRING is a string or a symbol.  They
default to 0 and (length (string FILESPEC)) respectively.  When the parsing is
failed, signals an error (if JUNK-ALLOWED is NIL) or simply returns NIL.  HOST
and DEFAULTS are simply ignored in ECL.
"
CLOS::PARSE-SPECIALIZED-LAMBDA-LIST
#'"This function takes a method lambda list and outputs the list of required
arguments, the list of specializers and a new lambda list where the specializer
have disappeared."
PATHNAME
(FUNCTION "Function in COMMON-LISP package:
Syntax: (FILESPEC)

Returns a pathname specified by FILESPEC.  FILESPEC may be a symbol, a string,
a pathname, or a file stream.
" TYPE "
A pathname object identifies an external file or a collection of external
files.  A pathname object consists of six slots, HOST, DEVICE, DIRECTORY,
NAME, and TYPE.  HOST, DEVICE, and VERSION slots are meaningless in ECL,
though they are harmless at all.
A pathname is notated as #\\\"...\", where '...' is actually some information
on the pathname.  This depends on the version of ECL.  Refer to the ECL Report
for details.")
PATHNAME-DEVICE
#'"Function in COMMON-LISP package:
Syntax: (FILESPEC)

Returns the device slot of the pathname specified by FILESPEC.  FILESPEC may
be a symbol, a string, a pathname, or a file stream.
"
PATHNAME-DIRECTORY
#'"Function in COMMON-LISP package:
Syntax: (FILESPEC)

Returns the directory slot of the pathname specified by FILESPEC.  FILESPEC
may be a symbol, a string, a pathname, or a file stream.
"
PATHNAME-HOST
#'"Function in COMMON-LISP package:
Syntax: (FILESPEC)

Returns the host slot of the pathname specified by FILESPEC.  FILESPEC may be
a symbol, a string, a pathname, or a file stream.
"
PATHNAME-NAME
#'"Function in COMMON-LISP package:
Syntax: (FILESPEC)

Returns the name slot of the pathname specified by FILESPEC.  FILESPEC may be
a symbol, a string, a pathname, or a file stream.
"
PATHNAME-TYPE
#'"Function in COMMON-LISP package:
Syntax: (FILESPEC)

Returns the type slot of the pathname specified by FILESPEC.  FILESPEC may be
a symbol, a string, a pathname, or a file stream.
"
PATHNAME-VERSION
#'"Function in COMMON-LISP package:
Syntax: (FILESPEC)

Returns the version slot of the pathname specified by FILESPEC.  FILESPEC may
be a symbol, a string, a pathname, or a file stream.
"
PATHNAMEP
#'"Function in COMMON-LISP package:
Syntax: (X)

Returns T if X is a pathname object; NIL otherwise.
"
PEEK-CHAR
#'"Function in COMMON-LISP package:
Syntax: (&OPTIONAL (CHAR-SPEC NIL) (STREAM *STANDARD-INPUT*) (EOF-ERROR-P T) (EOF-VALUE NIL) (RECURSIVE-P NIL))

Reads characters from STREAM until the specified character is read.  Returns
the last character but leaves it in STREAM.  CHAR-SPEC may be a character
object, T (specifies non-whitespace characters), or NIL (specifies all
characters).
"
PHASE
#'"Args: (number)
Returns the angle part (in radians) of the polar representation of NUMBER.
Returns zero for non-complex numbers."
PI
(VARIABLE "Constant in COMMON-LISP package:
The float that is approximately equal to the ratio of the circumference of the
circle to the diameter.
")
PLUSP
#'"Function in COMMON-LISP package:
Syntax: (NUMBER)

Returns T if NUMBER is positive; NIL otherwise.
"
SI:POINTER
#'"Function in SI package:
Syntax: (OBJECT)

ECL specific.
Returns the address of the OBJECT as a fixnum.
"
POP
#'"Syntax: (pop place)
Gets the cdr of the value stored in PLACE and makes it the new value of PLACE.
Returns the car of the old value in PLACE."
POSITION
#'"Function in COMMON-LISP package:
Syntax: (ITEM SEQUENCE &KEY (KEY '#'IDENTITY) (TEST '#'EQL) TEST-NOT (START 0) (END (LENGTH SEQUENCE)) (FROM-END NIL))

Returns the index to the first element in SEQUENCE that is equal to ITEM in
the sense of TEST.  Returns NIL if no such element exists.
"
POSITION-IF
#'"Function in COMMON-LISP package:
Syntax: (TEST SEQUENCE &KEY (KEY '#'IDENTITY) (START 0) (END (LENGTH SEQUENCE)) (FROM-END NIL))

Returns the index to the first element in SEQUENCE that satisfies TEST.
Returns NIL if no such element exists.
"
POSITION-IF-NOT
#'"Function in COMMON-LISP package:
Syntax: (TEST SEQUENCE &KEY (KEY '#'IDENTITY) (START 0) (END (LENGTH SEQUENCE)) (FROM-END NIL))

Returns the index to the first element in SEQUENCE that does not satisfy TEST.
Returns NIL if no such element exists.
"
PPRINT
#'"Function in COMMON-LISP package:
Syntax: (OBJECT &OPTIONAL (STREAM *STANDARD-OUTPUT*))

Pretty-prints OBJECT.  Returns no values.  Equivalent to
	(PROGN (WRITE OBJECT :STREAM STREAM :PRETTY T :ESCAPE T)
	       (VALUES))
The SI::PRETTY-PRINT-FORMAT property N (which must be a non-negative integer)
of a symbol SYMBOL controls the pretty-printing of form
	(SYMBOL f1 ... fN fN+1 ... fM)
in such a way that the subforms fN+1, ..., fM are regarded as the 'body' of
the entire form.  For instance, the property value of 2 is initially given to
the symbol DO.
"
PPRINT-EXIT-IF-LIST-EXHAUSTED
#'"Cause the closest enclosing use of PPRINT-LOGICAL-BLOCK to return
   if it's list argument is exhausted.  Can only be used inside
   PPRINT-LOGICAL-BLOCK, and only when the LIST argument to
   PPRINT-LOGICAL-BLOCK is supplied."
PPRINT-FILL
#'"Output LIST to STREAM putting :FILL conditional newlines between each
   element.  If COLON? is NIL (defaults to T), then no parens are printed
   around the output.  ATSIGN? is ignored (but allowed so that PPRINT-FILL
   can be used with the ~/.../ format directive."
PPRINT-INDENT
#'"Specify the indentation to use in the current logical block if STREAM
   (which defaults to *STANDARD-OUTPUT*) is it is a pretty-printing stream
   and do nothing if not.  (See PPRINT-LOGICAL-BLOCK.)  N is the indention
   to use (in ems, the width of an ``m'') and RELATIVE-TO can be either:
     :BLOCK - Indent relative to the column the current logical block
        started on.
     :CURRENT - Indent relative to the current column.
   The new indention value does not take effect until the following line
   break."
PPRINT-LINEAR
#'"Output LIST to STREAM putting :LINEAR conditional newlines between each
   element.  If COLON? is NIL (defaults to T), then no parens are printed
   around the output.  ATSIGN? is ignored (but allowed so that PPRINT-LINEAR
   can be used with the ~/.../ format directive."
PPRINT-LOGICAL-BLOCK
#'"Group some output into a logical block.  STREAM-SYMBOL should be either a
   stream, T (for *TERMINAL-IO*), or NIL (for *STANDARD-OUTPUT*).  The printer
   control variable *PRINT-LEVEL* is automatically handled."
PPRINT-NEWLINE
#'"Output a conditional newline to STREAM (which defaults to
   *STANDARD-OUTPUT*) if it is a pretty-printing stream, and do
   nothing if not.  KIND can be one of:
     :LINEAR - A line break is inserted if and only if the immediatly
        containing section cannot be printed on one line.
     :MISER - Same as LINEAR, but only if ``miser-style'' is in effect.
        (See *PRINT-MISER-WIDTH*.)
     :FILL - A line break is inserted if and only if either:
       (a) the following section cannot be printed on the end of the
           current line,
       (b) the preceding section was not printed on a single line, or
       (c) the immediately containing section cannot be printed on one
           line and miser-style is in effect.
     :MANDATORY - A line break is always inserted.
   When a line break is inserted by any type of conditional newline, any
   blanks that immediately precede the conditional newline are ommitted
   from the output and indentation is introduced at the beginning of the
   next line.  (See PPRINT-INDENT.)"
PPRINT-POP
#'"Return the next element from LIST argument to the closest enclosing
   use of PPRINT-LOGICAL-BLOCK, automatically handling *PRINT-LENGTH*
   and *PRINT-CIRCLE*.  Can only be used inside PPRINT-LOGICAL-BLOCK.
   If the LIST argument to PPRINT-LOGICAL-BLOCK was NIL, then nothing
   is poped, but the *PRINT-LENGTH* testing still happens."
PPRINT-TAB
#'"If STREAM (which defaults to *STANDARD-OUTPUT*) is a pretty-printing
   stream, perform tabbing based on KIND, otherwise do nothing.  KIND can
   be one of:
     :LINE - Tab to column COLNUM.  If already past COLNUM tab to the next
       multiple of COLINC.
     :SECTION - Same as :LINE, but count from the start of the current
       section, not the start of the line.
     :LINE-RELATIVE - Output COLNUM spaces, then tab to the next multiple of
       COLINC.
     :SECTION-RELATIVE - Same as :LINE-RELATIVE, but count from the start
       of the current section, not the start of the line."
PPRINT-TABULAR
#'"Output LIST to STREAM tabbing to the next column that is an even multiple
   of TABSIZE (which defaults to 16) between each element.  :FILL style
   conditional newlines are also output between each element.  If COLON? is
   NIL (defaults to T), then no parens are printed around the output.
   ATSIGN? is ignored (but allowed so that PPRINT-TABULAR can be used with
   the ~/.../ format directive."
PRIN1
#'"Function in COMMON-LISP package:
Syntax: (OBJECT &OPTIONAL (STREAM *STANDARD-OUTPUT*))

Prints OBJECT in the way that the output can be reread later if possible.
Returns OBJECT.  Equivalent to (WRITE OBJECT :STREAM STREAM :ESCAPE T).
"
PRIN1-TO-STRING
#'"Args: (object)
PRIN1s OBJECT to a new string and returns the result.  Equivalent to
(WRITE-TO-STRING OBJECT :ESCAPE T)."
PRINC
#'"Function in COMMON-LISP package:
Syntax: (OBJECT &OPTIONAL (STREAM *STANDARD-OUTPUT*))

Prints OBJECT without escape characters.  Returns OBJECT.  Equivalent to
(WRITE OBJECT :STREAM STREAM :ESCAPE NIL).
"
PRINC-TO-STRING
#'"Args: (object)
PRINCs OBJECT to a new string and returns the result.  Equivalent to
(WRITE-TO-STRING OBJECT :ESCAPE NIL)."
PRINT
#'"Function in COMMON-LISP package:
Syntax: (OBJECT &OPTIONAL (STREAM *STANDARD-OUTPUT*))

Outputs a newline character, and then PRIN1s OBJECT.  Returns OBJECT.
Equivalent to
	(PROGN (TERPRI STREAM)
	       (WRITE OBJECT :STREAM STREAM :ESCAPE T))
"
PROBE-FILE
#'"Function in COMMON-LISP package:
Syntax: (FILESPEC)

Returns the full pathname of the specified file if it exists.  Returns NIL
otherwise.  FILESPEC may be a symbol, a string, a pathname, or a file stream.
"
SI:PROCESS-COMMAND-ARGS
#'"PROCESS-COMMAND-ARGS takes a list of arguments and processes according
to a set of rules. These rules are of the format

	(option-name nargs template [ :stop | :noloadrc | :loadrc ] )

OPTION-NAME is a string containing the command line option. NARGS is
the number of arguments that this option takes. TEMPLATE is a lisp
form where numbers from 0 to NARGS will be substituted by the
arguments, and which will be evaluated afterwards. The flags :STOP,
:NOLOADRC and :LOADRC denote whether to stop processing the command
line after this option and whether the initialization file will be
loaded before evaluating all forms.

An excerpt of the rules used by ECL:
'((\"--help\" 0 #0=(progn (princ *help-message* *standard-output*) (quit))
               :noloadrc)
  (\"-?\" 0 #0# :noloadrc)
  (\"-h\" 0 #0# :noloadrc)
  (\"-norc\" 0 nil :noloadrc)
  (\"--\" 0 nil :stop)
  (\"-eval\" 1 (eval (read-from-string 1))))
"
PROCLAIM
#'"Args: (decl-spec)
Gives a global declaration.  See DECLARE for possible DECL-SPECs."
PROG
#'"Syntax: (prog ({var | (var [init])}*) {decl}* {tag | statement}*)
Establishes a NIL block, binds each VAR to the value of INIT (which defaults
to NIL) in parallel, and executes STATEMENTs.  Returns NIL."
PROG*
#'"Syntax: (prog* ({var | (var [init])}*) {decl}* {tag | statement}*)
Establishes a NIL block, binds each VAR to the value of INIT (which defaults
to NIL) sequentially, and executes STATEMENTs.  Returns NIL."
PROG1
#'"Syntax: (prog1 first-form {form}*)
Evaluates FIRST-FORM and FORMs in order.  Returns the value of FIRST-FORM."
PROG2
#'"Syntax: (prog2 first-form second-form {forms}*)
Evaluates FIRST-FORM, SECOND-FORM, and FORMs in order.  Returns the value of
SECOND-FORM."
PROGN
#'"Special Form in COMMON-LISP package:
Syntax: (progn {form}*)

Evaluates FORMs in order, and returns all values of the last FORM.  Returns
NIL if no FORM is given.
"
PROGV
#'"Special Form in COMMON-LISP package:
Syntax: (progv symbols-form values-form {form}*)

Evaluates SYMBOLS-FORM and VALUES-FORM.  The value of SYMBOLS-FORM must be a
list of symbols (S1 ... Sn) and the value of VALUES-FORM must be a list
(V1 ... Vm).  Binds each Si to Vi or to NIL if i > m.  Then evaluates FORMs
and returns all values of the last FORM.  Returns NIL if no FORM is given.
"
PROVIDE
#'"Adds a new module name to *MODULES* indicating that it has been loaded.
Module-name is a string designator"
PSETF
#'"Syntax: (psetf {place form}*)
Similar to SETF, but evaluates all FORMs first, and then assigns each value to
the corresponding PLACE.  Returns NIL."
PSETQ
#'"Syntax: (psetq {var form}*)
Similar to SETQ, but evaluates all FORMs first, and then assigns each value to
the corresponding VAR.  Returns NIL."
PUSH
#'"Syntax: (push form place)
Evaluates FORM, conses the value of FORM to the value stored in PLACE, and
makes it the new value of PLACE.  Returns the new value of PLACE."
PUSHNEW
#'"Syntax: (pushnew form place {keyword-form value-form}*)
Evaluates FORM first.  If the value is already in the list stored in PLACE,
does nothing.  Else, conses the value onto the list and makes the result the
new value of PLACE.  Returns NIL.  KEYWORD-FORMs and VALUE-FORMs are used to
check if the value of FORM is already in PLACE as if their values are passed
to MEMBER."
QUOTE
#'"Special Form in COMMON-LISP package:
Syntax: (quote x) | 'x

Simply returns X without evaluating it.
"
RANDOM
#'"Function in COMMON-LISP package:
Syntax: (NUMBER &OPTIONAL (RANDOM-STATE *RANDOM-STATE*))

Creates and returns a random number by using RANDOM-STATE.  NUMBER must be
either a positive integer or a positive float.  If NUMBER is a positive
integer, returns a positive integer less than NUMBER.  If NUMBER is a positive
float, returns a positive float less than NUMBER in the same float format as
NUMBER.
"
RANDOM-STATE
(TYPE "
A random-state object stores information used to generate random numbers.  A
random-state is notated as '#$' followed by a certain number.")
RANDOM-STATE-P
#'"Function in COMMON-LISP package:
Syntax: (X)

Returns T if X is a random-state object; NIL otherwise.
"
RASSOC
#'"Function in COMMON-LISP package:
Syntax: (ITEM ALIST &KEY (TEST '#'EQL) TEST-NOT (KEY '#'IDENTITY))

Returns the first pair in ALIST whose cdr is equal (in the sense of TEST) to
ITEM.  Returns NIL if no such pair exists.
The function KEY is applied to extract the key for comparison.
"
RASSOC-IF
#'"Returns the first pair in ALIST whose cdr satisfies TEST. Returns NIL if no
such pair exists."
RASSOC-IF-NOT
#'"Returns the first pair in ALIST whose cdr does not satisfy TEST.  Returns NIL
if no such pair exists."
RATIO
(TYPE "
A ratio is notated by its numerator and denominator, separated by a slash '/'.
Normally, a ratio is notated in radix 10 (see *PRINT-BASE* and *READ-BASE*) as
	[sign] {digit}+ / {digit}+
where DIGIT is a decimal digit ('0', ..., '9') and SIGN is either '+' or '-'.
Also, the following syntax is used to notate the radix explicitly.
	# radix {r | R} [sign] {digit}+ / {digit}+
where RADIX is one of '2', '3', ..., '36' and DIGIT is a digit in radix RADIX:
	Digits in radix 2 are '0' and '1'
	Digits in radix 8 are '0', ..., '7'
	Digits in radix 16 are '0', ..., '9', 'a', ..., 'f', and 'A', ..., 'F'
The following syntax is also available for radix 2, 8, 10, and 16.
	# {b | B} [sign] {digit}+ / {digit}+
	# {o | O} [sign] {digit}+ / {digit}+
	# {x | X} [sign] {digit}+ / {digit}+")
RATIONAL
(TYPE "
A ratio is either an integer or a ratio." FUNCTION "Function in COMMON-LISP package:
Syntax: (REAL)

Converts REAL into rational accurately and returns the result.
")
RATIONALIZE
#'"Function in COMMON-LISP package:
Syntax: (REAL)

Converts REAL into rational approximately and returns the result.
"
RATIONALP
#'"Function in COMMON-LISP package:
Syntax: (X)

Returns T if X is an integer or a ratio; NIL otherwise.
"
READ
#'"Function in COMMON-LISP package:
Syntax: (&OPTIONAL (STREAM *STANDARD-INPUT*) (EOF-ERROR-P T) (EOF-VALUE NIL) (RECURSIVEP NIL))

Reads an object from STREAM and returns the object.
"
READ-BYTE
#'"Function in COMMON-LISP package:
Syntax: (STREAM &OPTIONAL (EOF-ERROR-P T) (EOF-VALUE NIL))

Reads one byte from STREAM and returns it as an integer.
"
READ-CHAR
#'"Function in COMMON-LISP package:
Syntax: (&OPTIONAL (STREAM *STANDARD-INPUT*) (EOF-ERROR-P T) (EOF-VALUE NIL) (RECURSIVE-P NIL))

Reads a character from STREAM and returns it.
"
READ-CHAR-NO-HANG
#'"Function in COMMON-LISP package:
Syntax: (&OPTIONAL (STREAM *STANDARD-INPUT*) (EOF-ERROR-P T) (EOF-VALUE NIL) (RECURSIVE-P NIL))

Returns the next character from STREAM if one is available; NIL otherwise.
"
READ-DELIMITED-LIST
#'"Function in COMMON-LISP package:
Syntax: (CHAR &OPTIONAL (STREAM *STANDARD-INPUT*) (RECURSIVE-P NIL))

Reads objects from STREAM until the next character after an object's
representation is CHAR.  Returns all objects read, as a list.
"
READ-FROM-STRING
#'"Args: (string &optional (eof-error-p t) (eof-value nil)
              &key (start 0) (end (length string)) (preserve-whitespace nil))
Reads an object from STRING and returns the object.  As the second value,
returns the index to the character next to the object's representation.
PRESERVE-WHITESPACE specifies whether to leave the character next to the
object's representation."
READ-LINE
#'"Function in COMMON-LISP package:
Syntax: (&OPTIONAL (STREAM *STANDARD-INPUT*) (EOF-ERROR-P T) (EOF-VALUE NIL) (RECURSIVE-P NIL))

Reads a line of characters from STREAM and returns them as a string.  The
newline character at the end of the line will be discarded.
"
READ-PRESERVING-WHITESPACE
#'"Function in COMMON-LISP package:
Syntax: (&OPTIONAL (STREAM *STANDARD-INPUT*) (EOF-ERROR-P T) (EOF-VALUE NIL) (RECURSIVE-P NIL))

Reads an object from STREAM and returns the object.  Unlike READ, always
leaves the character next to the object's representation.
"
READTABLE
(TYPE "
A readtable defines the syntax used to read objects.
Each readtable object remembers the syntactic class of each character.  The
following syntactic classes are supported.  The characters in parenthesis
below are those standard characters that belong to each syntactic class as
defined in the standard readtable.
	white-space (space and newline)
	single-escape ( \\ )
	multiple-escape ( | )
	macro-character ( \"  #  '  (  )  ,  ;  ` )
	constituent (the others)
For each macro-character, the readtable remembers the definition of the
associated read macro and the non-terminating-p flag.  In the standard
readtable, only single-quote is non-terminating.  Dispatch macro characters
are classified to macro-characters.  A readtable is notated as
	#<readtable n>
where N is actually a number that identifies the readtable.")
READTABLEP
#'"Function in COMMON-LISP package:
Syntax: (X)

Returns T if X is a readtable object; NIL otherwise.
"
REALPART
#'"Function in COMMON-LISP package:
Syntax: (NUMBER)

Returns the realpart of NUMBER if it is a complex.  Otherwise, returns NUMBER.
"
GRAY::REDEFINE-CL-FUNCTIONS
#'"Some functions in CL package are expected to be generic. We make them so."
REDUCE
#'"Function in COMMON-LISP package:
Syntax: (FUNCTION SEQUENCE &KEY (FROM-END NIL) (START 0) (END (LENGTH SEQUENCE)) INITIAL-VALUE)

Combines all the elements of SEQUENCE using the binary operation FUNCTION.
"
REM
#'"Function in COMMON-LISP package:
Syntax: (NUMBER DIVISOR)

Returns the second value of (TRUNCATE NUMBER DIVISOR), i.e. the value of
	(- NUMBER (* (TRUNCATE NUMBER DIVISOR) DIVISOR))
"
REMF
#'"Syntax: (remf place form)
Removes the property specified by FORM from the property list stored in PLACE.
Returns T if the property list had the specified property; NIL otherwise."
REMHASH
#'"Function in COMMON-LISP package:
Syntax: (KEY HASH-TABLE)

Removes the entry for KEY in HASH-TABLE.  Returns T if such an entry existed;
NIL otherwise.
"
REMOVE
#'"Function in COMMON-LISP package:
Syntax: (ITEM SEQUENCE &KEY (KEY '#'IDENTITY) (TEST '#'EQL) TEST-NOT (START 0) (END (LENGTH SEQUENCE)) (COUNT MOST-POSITIVE-FIXNUM) (FROM-END NIL))

Returns a copy of SEQUENCE with those elements equal to ITEM (in the sense of
TEST) removed.
"
REMOVE-DUPLICATES
#'"Args: (sequence
       &key key (test '#'eql) test-not
            (start 0) (end (length sequence)) (from-end nil))
Returns a copy of SEQUENCE without duplicated elements."
REMOVE-IF
#'"Function in COMMON-LISP package:
Syntax: (TEST SEQUENCE &KEY (KEY '#'IDENTITY) (START 0) (END (LENGTH SEQUENCE)) (COUNT MOST-POSITIVE-FIXNUM) (FROM-END NIL))

Returns a copy of SEQUENCE with elements satisfying TEST removed.
"
REMOVE-IF-NOT
#'"Function in COMMON-LISP package:
Syntax: (TEST SEQUENCE &KEY (KEY '#'IDENTITY) (START 0) (END (LENGTH SEQUENCE)) (COUNT MOST-POSITIVE-FIXNUM) (FROM-END NIL))

Returns a copy of SEQUENCE with elements not satisfying TEST removed.
"
REMPROP
#'"Function in COMMON-LISP package:
Syntax: (SYMBOL INDICATOR)

Removes the specified property from the property list associated with SYMBOL.
Returns T if the property list had the specified property; NIL otherwise.
"
RENAME-FILE
#'"Function in COMMON-LISP package:
Syntax: (FILESPEC NEW-FILESPEC &KEY (IF-EXISTS ERROR))

Renames the file specified by FILESPEC as specified by NEW-FILESPEC.  Returns
as three values the new pathname, the old full pathname, and the new full
pathname.  FILESPEC and NEW-FILESPEC may be a symbol, a string, a pathname, or
a file stream.

:IF-EXISTS is an ECL-specific extension that modifies the behavior of rename-file
if new-filespec already exists. It may be :ERROR (the default), NIL, :SUPERSEDE,
or T.
"
RENAME-PACKAGE
#'"Function in COMMON-LISP package:
Syntax: (PACKAGE NEW-NAME &OPTIONAL (NEW-NICKNAMES NIL))

Renames PACKAGE to NEW-NAME and replaces the nicknames with NEW-NICKNAMES.
See MAKE-PACKAGE.
"
REPLACE
#'"Function in COMMON-LISP package:
Syntax: (SEQUENCE1 SEQUENCE2 &KEY (START1 0) (END1 (LENGTH SEQUENCE1)) (START2 0) (END2 (LENGTH SEQUENCE2)))

Replaces elements of SEQUENCE1 with the corresponding elements of SEQUENCE2.
SEQUENCE1 may be destroyed and is returned.
"
REQUIRE
#'"Loads a module, unless it already has been loaded. PATHNAMES, if supplied,
is a designator for a list of pathnames to be loaded if the module
needs to be. If PATHNAMES is not supplied, functions from the list
*MODULE-PROVIDER-FUNCTIONS* are called in order with MODULE-NAME
as an argument, until one of them returns non-NIL.  User code is
responsible for calling PROVIDE to indicate a successful load of the
module."
REST
#'"Function in COMMON-LISP package:
Syntax: (X)

Equivalent to CDR.
"
RETURN
#'"Macro in COMMON-LISP package:
Syntax: (return [result])

Terminates execution of the lexically surrounding NIL block and returns all
values of RESULT (which defaults to NIL) as the values of the terminated
block.
"
RETURN-FROM
#'"Special Form in COMMON-LISP package:
Syntax: (return-from symbol [result])

Terminates execution of the lexically surrounding block named SYMBOL and
returns all values of RESULT (which defaults to NIL) as the values of the
terminated block.
"
REVAPPEND
#'"Function in COMMON-LISP package:
Syntax: (X Y)

Equivalent to (APPEND (REVERSE X) Y)
"
REVERSE
#'"Function in COMMON-LISP package:
Syntax: (SEQUENCE)

Returns a new sequence containing the same elements as SEQUENCE but in the
reverse order.
"
ROOM
#'"Args: (&optional (x t))
Displays information about storage allocation in the following format.
	* for each type class
		* number of pages so-far allocated for the type class
		* maximum number of pages for the type class
		* percentage of used cells to cells so-far allocated
		* number of times the garbage collector has been called to
		  collect cells of the type class
		* implementation types that belongs to the type class
	* number of pages actually allocated for contiguous blocks
	* maximum number of pages for contiguous blocks
	* number of times the garbage collector has been called to collect
	  contiguous blocks
	* number of pages in the hole
	* total number of pages allocated for cells
	* total number of pages allocated
	* number of available pages
	* number of pages ECL can use.
The number of times the garbage collector has been called is not shown, if the
number is zero.  The optional X is simply ignored."
ROTATEF
#'"Syntax: (rotatef {place}*)
Saves the values of PLACEs, and then assigns to each PLACE the saved value of
the PLACE to its right.  The rightmost PLACE gets the value of the leftmost
PLACE.  Returns NIL."
ROUND
#'"Function in COMMON-LISP package:
Syntax: (NUMBER &OPTIONAL (DIVISOR 1))

Returns the integer nearest to NUMBER/DIVISOR.  Returns the value of (- NUMBER
(* first-value DIVISOR)) as the second value.
"
RPLACA
#'"Function in COMMON-LISP package:
Syntax: (CONS X)

Replaces the car of CONS with X, and returns the modified CONS.
"
RPLACD
#'"Function in COMMON-LISP package:
Syntax: (CONS X)

Replaces the cdr of CONS with X, and returns the modified CONS.
"
SI:SAFE-EVAL
#'"Args: (FORM ENV &optional ERR-VALUE)
Evaluates FORM in the given environment, which may be NIL. If the form
signals an error, or tries to jump to an outer point, the function has two
choices: by default, it will invoke a debugger, but if a third value is
supplied, then SAFE-EVAL will not use a debugger but rather return that
value."
SI::SAVE
#'"Function in SI package:
Syntax: (FILESPEC)

ECL specific.
Saves the current ECL core image into a program file specified by PATHNAME.
FILESPEC may be a symbol, a string, a pathname, or a file stream.  This
function depends on the version of ECL.  See ECL Report for details.
"
SBIT
#'"Args: (simple-bit-array &rest subscripts)
Returns the specified bit in SIMPLE-BIT-ARRAY."
SCALE-FLOAT
#'"Function in COMMON-LISP package:
Syntax: (FLOAT INTEGER)

Returns the value of (* FLOAT (expt (float-radix FLOAT) INTEGER)).
"
SCHAR
#'"Function in COMMON-LISP package:
Syntax: (SIMPLE-STRING N)

Returns the character object representing the N-th character in SIMPLE-STRING.
This is faster than CHAR.
"
SEARCH
#'"Args: (sequence1 sequence2
       &key key (test '#'eql) test-not
            (start1 0) (end1 (length sequence1))
            (start2 0) (end2 (length sequence2))
            (from-end nil))
Searches SEQUENCE2 for a subsequence that element-wise matches SEQUENCE1.
Returns the index to the first element of the subsequence if such a
subsequence is found.  Returns NIL otherwise."
SECOND
#'"Function in COMMON-LISP package:
Syntax: (X)

Equivalent to CADR.
"
SEQUENCE
(TYPE "A sequence is either a list or a vector.")
SET
#'"Function in COMMON-LISP package:
Syntax: (SYMBOL OBJECT)

Assigns OBJECT to the global variable named SYMBOL.  Returns OBJECT.
"
SI::SET-CHAR-BIT
#'"Function in SI package:
Syntax: (CHAR BIT-NAME FLAG)

Returns a character with the same code and attributes as CHAR except the
bit specified by BIT-NAME is on (if FLAG is non-NIL) or off. In ECL, the
bit-attributes handled are :control :meta :super and :hyper
"
SET-DIFFERENCE
#'"Args: (list1 list2 &key (key #'identity) (test #'eql) test-not)
Returns, as a list, those elements of LIST1 that are not elements of LIST2."
SET-DISPATCH-MACRO-CHARACTER
#'"Function in COMMON-LISP package:
Syntax: (CHAR SUBCHAR FUNCTION &OPTIONAL (READTABLE *READTABLE*))

Replaces FUNCTION for the read macro of SUBCHAR associated with the dispatch
macro character CHAR in READTABLE.  When the ECL reader reads an object that
begins with CHAR followed by SUBCHAR, it calls FUNCTION with the input stream,
SUBCHAR, and NIL as arguments.  When the ECL reader reads an object that
begins with CHAR, followed by a decimal representation of a number N, followed
by SUB-CHAR, it calls FUNCTION with N as the third argument.  In both cases,
if FUNCTION returns a single value, then that value is returned as the value
of the reader.  If FUNCTION returns no value, then the reader tries to read an
object again.  See MAKE-DISPATCH-MACRO-CHARACTER and GET-DISPATCH-MACRO-
CHARACTER.
"
SET-EXCLUSIVE-OR
#'"Args: (list1 list2 &key (key #'identity) (test #'eql) test-not)
Returns, as a list, those elements of LIST1 that are not elements of LIST2 and
those elements of LIST2 that are not elements of LIST1."
SI::SET-HOLE-SIZE
#'"Function in SI package:
Syntax: (FIXNUM)

ECL specific.
Sets the size of the memory hole (in pages).
"
SET-MACRO-CHARACTER
#'"Function in COMMON-LISP package:
Syntax: (CHAR FUNCTION &OPTIONAL (NON-TERMINATING-P NIL) (READTABLE *READTABLE*))

Registers CHAR as a macro character in READTABLE and makes FUNCTION the read
macro associated with CHAR.  When the ECL reader reads an object that begins
with CHAR, it calls FUNCTION with the input stream and CHAR as arguments.  If
FUNCTION returns a single value, it is returned as the value of the reader.
If FUNCTION returns no value, then the reader tries to read an object again.
NON-TERMINATING-P specifies whether CHAR is non-terminating or not (see
READTABLE).
Use GET-MACRO-CHARACTER to get the read macro associated with a character.
"
SET-SYNTAX-FROM-CHAR
#'"Function in COMMON-LISP package:
Syntax: (TO-CHAR FROM-CHAR &OPTIONAL (TO-READTABLE *READTABLE*) (FROM-READTABLE NIL))

Replaces the information for TO-CHAR in TO-READTABLE with the information for
FROM-CHAR in FROM-READTABLE.  If FROM-READTABLE is NIL, then the standard
readtable is used.  TO-CHAR belongs to the same syntactic class as FROM-CHAR,
and if FROM-CHAR is a macro character, TO-CHAR inherits the read macro and
non-terminating-p flag of FROM-CHAR.  See READTABLE.
"
SETF
#'"Syntax: (setf {place form}*)
Evaluates each FORM and assigns the value to the corresponding PLACE in order.
Returns the value of the last FORM.
Each PLACE may be any one of the following:
  * A symbol that names a variable.
  * A function call form whose first element is the name of the following
    functions:
	nth	elt	subseq	rest	first ... tenth
	c?r	c??r	c???r	c????r
	aref	svref	char	schar	bit	sbit	fill-pointer
	get	getf	documentation	symbol-value	symbol-function
	symbol-plist	macro-function	gethash		fdefinition
	char-bit	ldb	mask-field
	apply	slot-value
    where '?' stands for either 'a' or 'd'.
  * A function call form whose first element is:
        1. an access function for a structure slot
        1. an accessor method for a CLOS object
  * the form (THE type place) with PLACE being a place recognized by SETF.
  * a macro call which expands to a place recognized by SETF.
  * any form for which a DEFSETF or DEFINE-SETF-EXPANDER declaration has been
    made."
SETQ
#'"Special Form in COMMON-LISP package:
Syntax: (setq {var form}*)

Evaluates each FORM and assigns the value to VAR in order.  Returns the value
of the last FORM.
"
SEVENTH
#'"Function in COMMON-LISP package:
Syntax: (X)

Equivalent to (CADDR (CDDDDR X)).
"
SHADOW
#'"Function in COMMON-LISP package:
Syntax: (SYMBOL &OPTIONAL (PACKAGE *PACKAGE*))

If no symbol is registered in PACKAGE with the same name as SYMBOL, then
creates an internal symbol with the same name and registers it into PACKAGE.
The created symbol shadows external symbols of the same name in those packages
that PACKAGE uses.  SYMBOL may be a list of symbols.
"
SHADOWING-IMPORT
#'"Function in COMMON-LISP package:
Syntax: (SYMBOL &OPTIONAL (PACKAGE *PACKAGE*))

Registers SYMBOL as an internal symbol of PACKAGE.  Does nothing if SYMBOL is
already registered in PACKAGE.  If there exists already a symbol in PACKAGE
with the same name, then uninterns the symbol first.  SYMBOL shadows external
symbols of the same name in those packages that PACKAGE uses.  SYMBOL may be a
list of symbols.
"
SHIFTF
#'"Syntax: (shiftf {place}+ form)
Saves the values of PLACE and FORM, and then assigns the value of each PLACE
to the PLACE on its left.  The rightmost PLACE gets the value of FORM.
Returns the original value of the leftmost PLACE."
SHORT-FLOAT
(TYPE "
A short-float is a short-precision floating point number.")
SHORT-FLOAT-EPSILON
(VARIABLE "The smallest postive short-float E that satisfies
	(not (= (float 1 E) (+ (float 1 E) E)))")
SHORT-FLOAT-NEGATIVE-EPSILON
(VARIABLE "The smallest positive short-float E that satisfies
	(not (= (float 1 E) (- (float 1 E) E)))")
SHORT-SITE-NAME
#'"Args: ()
Returns, as a string, the location of the machine on which ECL runs."
SI::SHRINK-VECTOR
#'"Shrinks a vector. Optimized if vector has a fill pointer.
Needs to be a macro to overwrite value of VEC."
SIGNED-BYTE
(TYPE "As a type specifier, (SIGNED-BYTE n) specifies those integers that can be
represented with N bits in 2's complement representation.")
SIGNUM
#'"Args: (number)
Returns a number that represents the sign of NUMBER.  Returns NUMBER If it is
zero.  Otherwise, returns the value of (/ NUMBER (ABS NUMBER))"
SIMPLE-ARRAY
(TYPE "
A simple-array is an array that is not displaced to another array, has no
fill-pointer, and is not adjustable.")
SIMPLE-BASE-STRING
(TYPE "A base-string which cannot be adjusted nor displaced.")
SIMPLE-BIT-VECTOR
(TYPE "A bit-vector that is not displaced to another array, has no fill-pointer,
and is not adjustable.")
SIMPLE-BIT-VECTOR-P
#'"Function in COMMON-LISP package:
Syntax: (X)

Returns T if X is a simple-bit-vector; NIL otherwise.
"
SIMPLE-STRING
(TYPE "A simple-string is a string that is not displaced to another array, has no
fill-pointer, and is not adjustable.")
SIMPLE-STRING-P
#'"Function in COMMON-LISP package:
Syntax: (X)

Returns T if X is a simple-string; NIL otherwise.
"
SIMPLE-VECTOR
(TYPE "A simple-vector is a vector that is not displaced to another array, has no
fill-pointer, and is not adjustable.")
SIMPLE-VECTOR-P
#'"Function in COMMON-LISP package:
Syntax: (X)

Returns T if X is a simple-vector; NIL otherwise.
"
SIN
#'"Function in COMMON-LISP package:
Syntax: (RADIANS)

Returns the sine of RADIANS.
"
SINGLE-FLOAT
(TYPE "
A single-float is a single-precision floating point number.
SINGLE-FLOAT as a type specifier is equivalent to LONG-FLOAT in ECL.")
SINGLE-FLOAT-EPSILON
(VARIABLE "The smallest postive single-float E that satisfies
	(not (= (float 1 E) (+ (float 1 E) E)))")
SINGLE-FLOAT-NEGATIVE-EPSILON
(VARIABLE "The smallest positive single-float E that satisfies
	(not (= (float 1 E) (- (float 1 E) E)))")
SINH
#'"Function in COMMON-LISP package:
Syntax: (NUMBER)

Returns the hyperbolic sine of NUMBER.
"
SIXTH
#'"Function in COMMON-LISP package:
Syntax: (X)

Equivalent to (CADR (CDDDDR X)).
"
SI:SL-BOUNDP
#'"Function in SI package:
Syntax: (OBJECT)

ECL/CLOS specific.
Returns nil if the OBJECT is not null.
"
SI:SL-MAKUNBOUND
#'"Function in SI package:
Syntax: (INSTANCE INDEX)

ECL/CLOS specific.
Removes the value associated with the INDEX-th slot of INSTANCE.
"
SLEEP
#'"Function in COMMON-LISP package:
Syntax: (N)

Suspends execution for N seconds.  N may be any non-negative, non-complex
number.
"
SOFTWARE-TYPE
#'"Args: ()
Returns, as a string, the type of the software under which ECL runs."
SOFTWARE-VERSION
#'"Args: ()
Returns, as a string, the version of the software under which ECL runs."
SOME
#'"Args: (predicate sequence &rest more-sequences)
Returns T if at least one of the elements in SEQUENCEs satisfies PREDICATE;
NIL otherwise."
SORT
#'"Args: (sequence test &key key)
Destructively sorts SEQUENCE and returns the result.  TEST should return non-
NIL if its first argument is to precede its second argument.  The order of two
elements X and Y is arbitrary if both
	(FUNCALL TEST X Y)
	(FUNCALL TEST Y X)
evaluates to NIL.  See STABLE-SORT."
SPECIAL-OPERATOR-P
#'"Function in COMMON-LISP package:
Syntax: (SYMBOL)

Returns T if SYMBOL names a special form; NIL otherwise.
The special forms defined in Common Lisp are:
	block		if			progv
	catch		labels			quote
	compiler-let	let			return-from
	declare		let*			setq
	eval-when	macrolet		tagbody
	flet		multiple-value-call	the
	function	multiple-value-prog1	throw
	go		progn			unwind-protect
In addition, ECL implements the following macros as special forms, though of
course macro-expanding functions such as MACROEXPAND work correctly for these
macros.
	and		incf			prog1
	case		locally			prog2
	cond		loop			psetq
	decf		multiple-value-bind	push
	defmacro	multiple-value-list	return
	defun		multiple-value-set	setf
	do		or			unless
	do*		pop			when
	dolist		prog
	dotimes		prog*
"
SI:SPECIALP
#'"Function in SI package:
Syntax: (SYMBOL)

ECL specific.
Returns T if the SYMBOL names a globally special variable; NIL otherwise.
"
SQRT
#'"Function in COMMON-LISP package:
Syntax: (NUMBER)

Returns the square root of the arg.
"
STABLE-SORT
#'"Args: (sequence test &key key)
Destructively sorts SEQUENCE and returns the result.  TEST should return non-
NIL if its first argument is to precede its second argument.  For two elements
X and Y, if both
	(FUNCALL TEST X Y)
	(FUNCALL TEST Y X)
evaluates to NIL, then the order of X and Y are the same as in the original
SEQUENCE.  See SORT."
STANDARD-CHAR
(TYPE "
A standard-char is a space character (#\\Space), a newline character
(#\\Newline,) or a character that represents one of the following letters.
	!  \"  #  $  %  &  '  (  )  *  +  ,  -  .  /  0  1  2  3  4
	5  6  7  8  9  :  ;  <  =  >  ?  @  A  B  C  D  E  F  G  H
	I  J  K  L  M  N  O  P  Q  R  S  T  U  V  W  X  Y  Z  [  \\
	]  ^  _  `  a  b  c  d  e  f  g  h  i  j  k  l  m  n  o  p
	q  r  s  t  u  v  w  x  y  z  {  |  }  ~~")
STANDARD-CHAR-P
#'"Function in COMMON-LISP package:
Syntax: (CHAR)

Returns T if CHAR is a standard-char; NIL otherwise.
"
STEP
#'"Syntax: (step form)
Evaluates FORM in the Stepper mode and returns all its values.  See ECL Report
for Stepper mode commands."
STREAM
(TYPE "
A stream is a source of input or a destination of output.  The following kinds
of streams are supported.
	file streams
	string-input streams
	string-output streams
	two-way streams
	echo streams
	synonym streams
	concatenated streams
	broadcast streams
Basically, file streams are created by OPEN and other kinds of streams are
created by MAKE-...-STREAM.  See these functions.")
SI::STREAM-CLEAR-INPUT
#'"Generic function in SI package:
Syntax: ((OBJ STREAM-CLASS))

Clears any buffered characters received from the CLOS stream OBJ.
Returns NIL.
"
SI::STREAM-CLEAR-OUTPUT
#'"Generic function in SI package:
Syntax: ((OBJ STREAM-CLASS))

Aborts any outstanding output operation on the CLOS stream OBJ
and returns NIL .
"
STREAM-ELEMENT-TYPE
#'"Function in COMMON-LISP package:
Syntax: (STREAM)

Returns the type specifier for the io unit of STREAM.
"
SI::STREAM-FORCE-OUTPUT
#'"Generic function in SI package:
Syntax: ((OBJ STREAM-CLASS))

Initiates the emptying of internal buffers on the CLOS stream OBJ
and returns NIL.
"
SI::STREAM-FRESH-LINE
#'"Generic function in SI package:
Syntax: ((OBJ STREAM-CLASS))

Outputs a newline to the CLOS stream if and only if the CLOS stream OBJ
is not already at the beginning of a new line. Returns non-NIL if a
newline was output and NIL otherwise.
"
SI::STREAM-LISTEN
#'"Generic function in SI package:
Syntax: ((OBJ STREAM-CLASS))

Returns NIL if no character is immediately available from the CLOS stream.
Otherwise, the next character is returned, as if stream-peek-char
had been called.
"
SI::STREAM-PEEK-CHAR
#'"Generic function in SI package:
Syntax: ((OBJ STREAM-CLASS) PEEK-TYPE)

Returns the character object which would be returned by STREAM-READ-CHAR
but does not remove it from the input buffer.
If PEEK-TYPE is T, stream-peek-char skips over any whitespace characters,
removing them from the input buffer, and returns the next character.
"
SI::STREAM-READ-CHAR
#'"Generic function in SI package:
Syntax: ((OBJ STREAM-CLASS))

Reads the next character object from the CLOS stream OBJ.
"
SI::STREAM-READ-LINE
#'"Generic function in SI package:
Syntax: ((OBJ STREAM-CLASS) &REST MAKE-ARRAY-OPTIONS)

Reads character objects from the CLOS stream OBJ, up to and including the
next newline character, and returns them as a string (without the newline).
If given, the MAKE-ARRAY-OPTIONS arguments are passed to make-array
when the returned string is created.
"
SI::STREAM-UNREAD-CHAR
#'"Generic function in SI package:
Syntax: ((OBJ STREAM-CLASS) CHARACTER)

Unreads the character object.
CHARACTER will be the next character read by STREAM-READ-CHAR .
"
SI::STREAM-WRITE-CHAR
#'"Generic function in SI package:
Syntax: ((OBJ STREAM-CLASS) CHARACTER)

Outputs the CHARACTER to the CLOS stream OBJ and returns the CHARACTER.
"
SI::STREAM-WRITE-STRING
#'"Generic function in SI package:
Syntax: ((OBJ STREAM-CLASS) STRING &OPTIONAL START END)

Outputs characters in the STRING to the CLOS stream OBJ and returns the
STRING. The START and END arguments, if given, indicate a substring that
is to be output.
"
STREAMP
#'"Function in COMMON-LISP package:
Syntax: (X)

Returns T if X is a stream object; NIL otherwise.
"
STRING
(FUNCTION "Function in COMMON-LISP package:
Syntax: (X)

Coerces X into a string.  If X is a string, then returns X itself.  If X is a
symbol, then returns its print name.  If X is a character, then returns a one
element string containing that character.  Signals an error if X cannot be
coerced into a string.
" TYPE "A string is a vector of characters.  A string is notated by surrounding the
characters with double quotes.  Some strings may be displaced to another
string, may have a fill-pointer, or may be adjustable.  Other strings are
called simple-strings.")
STRING-CAPITALIZE
#'"Function in COMMON-LISP package:
Syntax: (STRING &KEY (START 0) (END (LENGTH STRING)))

Returns a copy of STRING with the first character of each word converted to
upper case, and remaining characters converted to lower case.  Its destructive
version is NSTRING-CAPITALIZE.
"
SI::STRING-CHAR
(TYPE "
A string-char is a character that can be stored in strings.  In ECL, every
character is a string-character.")
SI::STRING-CHAR-P
#'"Function in SI package:
Syntax: (CHAR)

Returns T if CHAR is a string-char, i.e. can be stored in strings; NIL
otherwise.  In ECL, this function always returns T.
"
SI::STRING-CONCATENATE
#'"Function in SI package:
Syntax: (&REST STRINGS)

ECL specific.
Concatenates STRINGs and returns the result.
"
STRING-DOWNCASE
#'"Function in COMMON-LISP package:
Syntax: (STRING &KEY (START 0) (END (LENGTH STRING)))

Returns a copy of STRING with all upper case characters converted to lower
case.  Its destructive version is NSTRING-DOWNCASE.
"
STRING-EQUAL
#'"Function in COMMON-LISP package:
Syntax: (STRING1 STRING2 &KEY (START1 0) (END1 (LENGTH STRING1)) (START2 0) (END2 (LENGTH STRING2)))

Returns T if STRING1 and STRING2 are character-wise CHAR-EQUAL; NIL otherwise.
"
STRING-GREATERP
#'"Function in COMMON-LISP package:
Syntax: (STRING1 STRING2 &KEY (START1 0) (END1 (LENGTH STRING1)) (START2 0) (END2 (LENGTH STRING2)))

Similar to STRING>, but ignores cases.
"
STRING-LEFT-TRIM
#'"Function in COMMON-LISP package:
Syntax: (CHAR-BAG STRING)

Returns a copy of STRING with the specified characters removed from the left
end.  CHAR-SPEC must be a sequence of characters.
"
STRING-LESSP
#'"Function in COMMON-LISP package:
Syntax: (STRING1 STRING2 &KEY (START1 0) (END1 (LENGTH STRING1)) (START2 0) (END2 (LENGTH STRING2)))

Similar to STRING<, but ignores cases.
"
STRING-NOT-EQUAL
#'"Function in COMMON-LISP package:
Syntax: (STRING1 STRING2 &KEY (START1 0) (END1 (LENGTH STRING1)) (START2 0) (END2 (LENGTH STRING2)))

Returns NIL if the strings are character-wise CHAR-EQUAL.  Otherwise, returns
the number of characters in the longest common prefix of the strings.
"
STRING-NOT-GREATERP
#'"Function in COMMON-LISP package:
Syntax: (STRING1 STRING2 &KEY (START1 0) (END1 (LENGTH STRING1)) (START2 0) (END2 (LENGTH STRING2)))

Similar to STRING<=, but ignores cases.
"
STRING-NOT-LESSP
#'"Function in COMMON-LISP package:
Syntax: (STRING1 STRING2 &KEY (START1 0) (END1 (LENGTH STRING1)) (START2 0) (END2 (LENGTH STRING2)))

Similar to STRING>=, but ignores cases.
"
STRING-RIGHT-TRIM
#'"Function in COMMON-LISP package:
Syntax: (CHAR-BAG STRING)

Returns a copy of STRING with the specified characters removed from the right
end.  CHAR-SPEC must be a sequence of characters.
"
SI:STRING-TO-OBJECT
#'"Function in SI package:
Syntax: (STRING)

ECL specific.
Equivalent to (READ-FROM-STRING STRING), but is much faster.
"
STRING-TRIM
#'"Function in COMMON-LISP package:
Syntax: (CHAR-SPEC STRING)

Returns a copy of STRING with the specified characters removed from both ends.
CHAR-SPEC must be a sequence of characters.
"
STRING-UPCASE
#'"Function in COMMON-LISP package:
Syntax: (STRING &KEY (START 0) (END (LENGTH STRING)))

Returns a copy of STRING with all lower case characters converted to upper
cases.  Its destructive version is NSTRING-UPCASE.
"
STRING/=
#'"Function in COMMON-LISP package:
Syntax: (STRING1 STRING2 &KEY (START1 0) (END1 (LENGTH STRING1)) (START2 0) (END2 (LENGTH STRING2)))

Returns NIL if the strings are character-wise CHAR=.  Otherwise, returns the
number of characters in the longest common prefix of the strings.
"
STRING<
#'"Function in COMMON-LISP package:
Syntax: (STRING1 STRING2 &KEY (START1 0) (END1 (LENGTH STRING1)) (START2 0) (END2 (LENGTH STRING2)))

If STRING1 comes before STRING2 in lexicographic order, then returns the
number of characters in the longest common prefix of the strings.  Otherwise,
returns NIL.
"
STRING<=
#'"Function in COMMON-LISP package:
Syntax: (STRING1 STRING2 &KEY (START1 0) (END1 (LENGTH STRING1)) (START2 0) (END2 (LENGTH STRING2)))

If STRING1 comes before STRING2 in lexicographic order or if the strings are
character-wise CHAR=, then returns the number of characters in the longest
common prefix of the strings.  Otherwise, returns NIL.
"
STRING=
#'"Function in COMMON-LISP package:
Syntax: (STRING1 STRING2 &KEY (START1 0) (END1 (LENGTH STRING1)) (START2 0) (END2 (LENGTH STRING2)))

Returns T if STRING1 and STRING2 are character-wise CHAR=; NIL otherwise.
"
STRING>
#'"Function in COMMON-LISP package:
Syntax: (STRING1 STRING2 &KEY (START1 0) (END1 (LENGTH STRING1)) (START2 0) (END2 (LENGTH STRING2)))

If STRING1 comes after STRING2 in lexicographic order or if the strings are
character-wise CHAR=, then returns the number of characters in the longest
common prefix of the strings.  Otherwise, returns NIL.
"
STRING>=
#'"Function in COMMON-LISP package:
Syntax: (STRING1 STRING2 &KEY (START1 0) (END1 (LENGTH STRING1)) (START2 0) (END2 (LENGTH STRING2)))

If STRING1 comes after STRING2 in lexicographic order or if the strings are
character-wise CHAR=, then returns the number of characters in the longest
common prefix of the strings.  Otherwise, returns NIL.
"
STRINGP
#'"Function in COMMON-LISP package:
Syntax: (X)

Returns T if X is a string object; NIL otherwise.
"
SI:STRUCTUREP
#'"Function in SI package:
Syntax: (X)

ECL specific.
Returns T if X is a structure object defined by DEFSTRUCT; NIL otherwise.
"
SUBLIS
#'"Function in COMMON-LISP package:
Syntax: (ALIST TREE &KEY (KEY '#'IDENTITY) (TEST '#'EQL) TEST-NOT)

Substitutes subtrees of TREE by using ALIST and returns the result.  The
original TREE is not destroyed.
"
SUBSEQ
#'"Function in COMMON-LISP package:
Syntax: (SEQUENCE START &OPTIONAL (END (LENGTH SEQUENCE)))

Returns a copy of the subsequence of SEQUENCE between START (inclusive) and
END (exclusive).
"
SUBSETP
#'"Args: (list1 list2 &key (key #'identity) (test #'eql) test-not)
Returns T if every element of LIST1 is also an element of LIST2.  Returns NIL
otherwise."
SUBST
#'"Function in COMMON-LISP package:
Syntax: (NEW OLD TREE &KEY (KEY '#'IDENTITY) (TEST '#'EQL) TEST-NOT)

Substitutes NEW for subtrees of TREE that match OLD and returns the result.
The original TREE is not destroyed.
"
SUBST-IF
#'"Substitutes NEW for subtrees of TREE that satisfy TEST and returns the result.
The original TREE is not destroyed."
SUBST-IF-NOT
#'"Substitutes NEW for subtrees of TREE that do not satisfy TEST and returns the
result.  The original TREE is not destroyed."
SUBSTITUTE
#'"Function in COMMON-LISP package:
Syntax: (NEW OLD SEQUENCE &KEY (KEY '#'IDENTITY) (TEST '#'EQL) TEST-NOT (START 0) (END (LENGTH SEQUENCE)) (COUNT MOST-POSITIVE-FIXNUM) (FROM-END NIL))

Returns a copy of SEQUENCE with all elements that match OLD replaced by NEW.
The original SEQUENCE is not destroyed.
"
SUBSTITUTE-IF
#'"Function in COMMON-LISP package:
Syntax: (NEW TEST SEQUENCE &KEY (KEY '#'IDENTITY) (START 0) (END (LENGTH SEQUENCE)) (COUNT MOST-POSITIVE-FIXNUM) (FROM-END NIL))

Returns a copy of SEQUENCE with all elements that satisfy TEST replaced by
NEW.  The original SEQUENCE is not destroyed.
"
SUBSTITUTE-IF-NOT
#'"Function in COMMON-LISP package:
Syntax: (NEW TEST SEQUENCE &KEY (KEY '#'IDENTITY) (START 0) (END (LENGTH SEQUENCE)) (COUNT MOST-POSITIVE-FIXNUM) (FROM-END NIL))

Returns a copy of SEQUENCE with all elements that do not satisfy TEST replaced
by NEW.  The original SEQUENCE is not destroyed.
"
SVREF
#'"Function in COMMON-LISP package:
Syntax: (SIMPLE-VECTOR N)

Returns the N-th element of SIMPLE-VECTOR.
"
SXHASH
#'"Function in COMMON-LISP package:
Syntax: (OBJECT)

Returns the hash code for OBJECT as an integer.
"
SYMBOL
(TYPE "
Symbol objects.")
SYMBOL-FUNCTION
#'"Function in COMMON-LISP package:
Syntax: (SYMBOL)

Returns the global function definition named SYMBOL.
"
SYMBOL-NAME
#'"Function in COMMON-LISP package:
Syntax: (SYMBOL)

Returns the print name of SYMBOL.
"
SYMBOL-PACKAGE
#'"Function in COMMON-LISP package:
Syntax: (SYMBOL)

Returns the home package of SYMBOL.  Returns NIL if SYMBOL is not interned.
"
SYMBOL-PLIST
#'"Function in COMMON-LISP package:
Syntax: (SYMBOL)

Returns the property list of SYMBOL.
"
SYMBOL-VALUE
#'"Function in COMMON-LISP package:
Syntax: (SYMBOL)

Returns the value of the global variable named SYMBOL.
"
SYMBOLP
#'"Function in COMMON-LISP package:
Syntax: (X)

Returns T if X is a symbol; NIL otherwise.
"
SI:SYSTEM
#'"Function in SI package:
Syntax: (STRING)

Executes a Shell command as if STRING is an input to the Shell.
"
T
(VARIABLE "Constant in COMMON-LISP package:
The value of T is T.
" TYPE "
The type T is a supertype of every type.  Every object belongs to this type.")
TAGBODY
#'"Special Form in COMMON-LISP package:
Syntax: (tagbody {tag | statement}*)

Executes STATEMENTs in order and returns NIL after the execution of the last
STATEMENT.  But, if a GO form causes a jump to one of the TAGs, then execution
continues at the point right after the TAG.  Lists are regarded as STATEMENTs
and other objects are regarded as TAGs.
"
TAILP
#'"Function in COMMON-LISP package:
Syntax: (X LIST)

Returns T if X is identical to one of the conses that constitute LIST.
Returns NIL otherwise.
"
TAN
#'"Function in COMMON-LISP package:
Syntax: (RADIANS)

Returns the tangent of RADIANS.
"
TANH
#'"Function in COMMON-LISP package:
Syntax: (NUMBER)

Returns the hyperbolic tangent of NUMBER.
"
TENTH
#'"Function in COMMON-LISP package:
Syntax: (X)

Equivalent to (CADR (CDDDDR (CDDDDR X))).
"
TERPRI
#'"Function in COMMON-LISP package:
Syntax: (&OPTIONAL (STREAM *STANDARD-OUTPUT*))

Outputs a newline character.
"
THE
#'"Special Form in COMMON-LISP package:
Syntax: (the type form)

Declares that FORM evaluates to a value of TYPE.  Evaluates FORM and checks if
the value belongs to TYPE.  If it does, returns the value.  Otherwise, signals
an error.
"
THIRD
#'"Function in COMMON-LISP package:
Syntax: (X)

Equivalent to CADDR.
"
THROW
#'"Special Form in COMMON-LISP package:
Syntax: (throw tag form)

Evaluates TAG and aborts the execution of the most recent CATCH form that
establishes a catcher with the same catch tag.  Returns all values of FORM as
the values of the CATCH form.
"
TIME
#'"Syntax: (time form)
Evaluates FORM, outputs the realtime and runtime used for the evaluation to
*TRACE-OUTPUT*, and then returns all values of FORM."
SI:TOP-LEVEL
#'"Args: ()
ECL specific.
The top-level loop of ECL. It is called by default when ECL is invoked."
TRACE
#'"Syntax: (trace ({function-name | ({function-name}+)} {keyword [form]}*)
Begins tracing the specified functions.  With no FUNCTION-NAMEs, returns a
list of functions currently being traced. The printed information consists of
the name of function followed at entry by its arguments and on exit by its
return values.
The keywords allow to control when and how tracing is performed.
The possible keywords are:

 :BREAK		a breakpoint is entered after printing the entry trace
		information, but before applying the traced function to its
		arguments, if form evaluates to non-nil
 :BREAK-AFTER 	like :BREAK but the breakpoint is entered after the function
		has been executed and the exit trace information has been
		printed and before control returns
 :COND-BEFORE	information is printed upon entry if form evaluates to non-nil
 :COND-AFTER	information is printed upon exit if form evaluates to non-nil
 :COND		specifies a single condition for both entry and exit
 :PRINT		prints the values of the forms in the list upon entry.
		They are preceeded by a backslash (\\)
 :PRINT-AFTER	prints the values of the forms in the list upon exit from the
		function. They are preceeded by a backslash (\\)
 :STEP		turns on the stepping facility

Forms can refer to the list of arguments of the function through the variable
SI::ARGS."
TREE-EQUAL
#'"Function in COMMON-LISP package:
Syntax: (X Y &KEY (TEST '#'EQL) TEST-NOT)

Returns T if X and Y have the same tree structures and corresponding leaves
are all the same in the sense of TEST.  Returns NIL otherwise.
"
TRUENAME
#'"Function in COMMON-LISP package:
Syntax: (FILESPEC)

Returns the full pathname of the file specified by FILESPEC.  FILESPEC may be
a symbol, a string, a pathname, or a file stream.
"
TRUNCATE
#'"Function in COMMON-LISP package:
Syntax: (NUMBER &OPTIONAL (DIVISOR 1))

Returns the integer obtained by truncating NUMBER/DIVISOR.  Returns the value
of (- NUMBER (* first-value DIVISOR)) as the second value.
"
TYPE-OF
#'"Function in COMMON-LISP package:
Syntax: (X)

Returns a type specifier of the type to which X belongs.
"
TYPECASE
#'"Syntax: (typecase keyform {(type {form}*)}*)
Evaluates KEYFORM and searches a TYPE to which the value of KEYFORM belongs.
If found, then evaluates FORMs that follow the TYPE and returns all values of
the last FORM.  If not, simply returns NIL.  The symbols T and OTHERWISE may
be used as a TYPE to specify the default case."
TYPEP
#'"Args: (object type)
Returns T if X belongs to TYPE; NIL otherwise."
UNEXPORT
#'"Function in COMMON-LISP package:
Syntax: (SYMBOL &OPTIONAL (PACKAGE *PACKAGE*))

Undoes the registration of SYMBOL as an external symbol of PACKAGE and makes
SYMBOL internal to PACKAGE.  SYMBOL may be a list of symbols.
"
UNINTERN
#'"Function in COMMON-LISP package:
Syntax: (SYMBOL &OPTIONAL (PACKAGE *PACKAGE*))

Removes SYMBOL from PACKAGE.  If PACKAGE is the home package of SYMBOL, then
makes SYMBOL uninterned.  Returns T if SYMBOL is actually registered in
PACKAGE; NIL otherwise.
"
UNION
#'"Args: (list1 list2 &key (key #'identity) (test #'eql) test-not)
Returns, as a list, the union of elements in LIST1 and in LIST2."
SI::UNIQUE-ID
#'"Generates a unique integer ID for its argument."
SI:UNIVERSAL-ERROR-HANDLER
#'"Args: (error-name continuable-p function-name
       continue-format-string error-format-string
       &rest args)
ECL specific.
Starts the error handler of ECL.
When an error is detected, ECL calls this function with the specified
arguments.  To change the error handler of ECL, redefine this function.
ERROR-NAME is the name of the error.  CONTINUABLE-P is T for a continuable
error and NIL for a fatal error.  FUNCTION-NAME is the name of the function
that caused the error.  CONTINUE-FORMAT-STRING and ERROR-FORMAT-STRING are the
format strings of the error message.  ARGS are the arguments to the format
strings."
UNREAD-CHAR
#'"Function in COMMON-LISP package:
Syntax: (CHAR &OPTIONAL (STREAM *STANDARD-INPUT*))

Puts CHAR back on the front of the input stream STREAM.
"
UNSIGNED-BYTE
(TYPE "As a type specifier, (UNSIGNED-BYTE n) specifies non-negative integers that
can be represented with N bits.")
UNTRACE
#'"Syntax: (untrace {function-name}*)

Ends tracing the specified functions.  With no FUNCTION-NAMEs, ends tracing
all functions."
UNUSE-PACKAGE
#'"Function in COMMON-LISP package:
Syntax: (PACKAGE-SPEC &OPTIONAL (PACKAGE *PACKAGE*))

Causes PACKAGE not to use packages specified by PACKAGE-SPEC.  PACKAGE-SPEC
may be a package object, a string, a symbol, or a list consisting of package
objects, strings, and, symbols.
"
UNWIND-PROTECT
#'"Special Form in COMMON-LISP package:
Syntax: (unwind-protect form {cleanup-form}*)

Evaluates FORM and returns all its values.  Before returning, evaluates
CLEANUP-FORMs in order, whether FORM returns normally or abnormally by a non-
local exit.
"
UPPER-CASE-P
#'"Function in COMMON-LISP package:
Syntax: (CHAR)

Returns T if CHAR is an upper-case character; NIL otherwise.
"
USE-PACKAGE
#'"Function in COMMON-LISP package:
Syntax: (PACKAGE-SPEC &OPTIONAL (PACKAGE *PACKAGE*))

Causes PACKAGE to use packages specified by PACKAGE-SPEC, in addition to those
packages that PACKAGE already uses.  PACKAGE-SPEC may be a package object, a
string, a symbol, or a list consisting of package objects, strings, and
symbols.
"
USER-HOMEDIR-PATHNAME
#'"Function in COMMON-LISP package:
Syntax: (&OPTIONAL HOST)

Returns a pathname the represents the user's home directory.  HOST is simply
ignored in ECL.
"
VALUES
#'"Function in COMMON-LISP package:
Syntax: (&REST ARGS)

Returns ARGs as multiple values, the N-th ARG being the N-th value.
"
VALUES-LIST
#'"Function in COMMON-LISP package:
Syntax: (LIST)

Returns all elements of LIST as multiple values, the N-th element of LIST
being the N-th value.
"
VECTOR
(FUNCTION "Args: (&rest objects)
Creates and returns a simple-vector, with the N-th OBJECT being the N-th
element." TYPE "A vector is a one-dimensional array.  Strings and bit-vectors are kinds of
vectors.  Other vectors are called general vectors and are notated as
	#(elem ... elem)
Some vectors may be displaced to another array, may have a fill-pointer, or
may be adjustable.  Other vectors are called simple-vectors.")
VECTOR-POP
#'"Args: (vector)
Decrements the fill-pointer of VECTOR by one and returns the element pointed
to by the new fill-pointer.  Signals an error if the old value of the fill-
pointer is 0 already."
VECTOR-PUSH
#'"Args: (item vector)
Replaces ITEM for the element of VECTOR that is pointed to by the fill-pointer
of VECTOR and then increments the fill-pointer by one.  Returns NIL if the new
value of the fill-pointer becomes too large.  Otherwise, returns the new fill-
pointer as the value."
VECTOR-PUSH-EXTEND
#'"Args: (item vector &optional (n (length vector)))
Replaces ITEM for the element of VECTOR that is pointed to by the fill-pointer
of VECTOR and then increments the fill-pointer by one.  If the new value of
the fill-pointer becomes too large, extends VECTOR for N more elements.
Returns the new value of the fill-pointer."
VECTORP
#'"Function in COMMON-LISP package:
Syntax: (X)

Returns T if X is a vector; NIL otherwise.
"
WARN
#'"Args: (format-string &rest args)
Formats FORMAT-STRING and ARGs to *ERROR-OUTPUT* as a warning message.  Enters
a break level if the value of *BREAK-ON-WARNINGS* is non-NIL.  Otherwise,
returns with NIL."
WHEN
#'"Macro in COMMON-LISP package:
Syntax: (when test {form}*)

If TEST evaluates to non-NIL, then evaluates FORMs and returns all values of
the last FORM.  If not, simply returns NIL.
"
SI:WITH-ECL-IO-SYNTAX
#'"Syntax: ({forms}*)
The forms of the body are executed in a print envirtoponment that corresponds to
the one used internally by ECL compiled files."
WITH-HASH-TABLE-ITERATOR
#'"Syntax: (with-hash-table-iterator (iterator package) &body body)
Loop over the elements of a hash table. ITERATOR is a lexically bound function
that outputs three values
	(VALUES entry-p key value)
ENTRY-P is true only if KEY and VALUE denote a pair of key and value of the
hash table; otherwise it signals that we have reached the end of the hash table."
WITH-INPUT-FROM-STRING
#'"Syntax: (with-input-from-string (var string-form {keyword value}*)
           {decl}* {form}*)
Evaluates FORMs with VAR bound to a string input stream from the string that
is the value of STRING-FORM.  The stream is automatically closed on exit.
Possible keywords are :INDEX, :START, and :END."
MP:WITH-INTERRUPTS
#'"Executes BODY with deferrable interrupts conditionally enabled. If there
are pending interrupts they take effect prior to executing BODY.

As interrupts are normally allowed WITH-INTERRUPTS only makes sense if there
is an outer WITHOUT-INTERRUPTS with a corresponding ALLOW-WITH-INTERRUPTS:
interrupts are not enabled if any outer WITHOUT-INTERRUPTS is not accompanied
by ALLOW-WITH-INTERRUPTS."
WITH-OPEN-FILE
#'"Syntax: (with-open-file (var filespec-form {options}*) {decl}* {form}*)
Opens the specified file using OPTIONs, and evaluates FORMs with VAR bound to
a stream to/from the file.  The file is automatically closed on exit.  See
OPEN for the options."
WITH-OPEN-STREAM
#'"Syntax: (with-open-stream (var stream-form) {decl}* {form}*)
Evaluates FORMs with VAR bound to the value of STREAM-FORM.  The stream is
automatically closed on exit."
WITH-OUTPUT-TO-STRING
#'"Syntax: (with-output-to-string (var [string-form]) {decl}* {form}*)
Evaluates FORMs with VAR bound to a string output stream to the string that is
the value of STRING-FORM.  If STRING-FORM is not given, a new string is used.
The stream is automatically closed on exit and the string is returned."
WITH-STANDARD-IO-SYNTAX
#'"Syntax: ({forms}*)
The forms of the body are executed in a print envirtoponment that corresponds to
the one defined in the ANSI standard. *print-base* is 10, *print-array* is t,
*package* is \"CL-USER\", etc."
MP:WITHOUT-INTERRUPTS
#'"Executes BODY with all deferrable interrupts disabled. Deferrable
interrupts arriving during execution of the BODY take effect after BODY has
been executed.

Deferrable interrupts include most blockable POSIX signals, and
SB-THREAD:INTERRUPT-THREAD. Does not interfere with garbage collection, and
unlike in many traditional Lisps using userspace threads, in SBCL
WITHOUT-INTERRUPTS does not inhibit scheduling of other threads.

Binds ALLOW-WITH-INTERRUPTS, WITH-LOCAL-INTERRUPTS and WITH-RESTORED-INTERRUPTS
as a local macros.

WITH-RESTORED-INTERRUPTS executes the body with interrupts enabled if and only
if the WITHOUT-INTERRUPTS was in an environment in which interrupts were allowed.

ALLOW-WITH-INTERRUPTS allows the WITH-INTERRUPTS to take effect during the
dynamic scope of its body, unless there is an outer WITHOUT-INTERRUPTS without
a corresponding ALLOW-WITH-INTERRUPTS.

WITH-LOCAL-INTERRUPTS executes its body with interrupts enabled provided that
for there is an ALLOW-WITH-INTERRUPTS for every WITHOUT-INTERRUPTS surrounding
the current one. WITH-LOCAL-INTERRUPTS is equivalent to:

  (allow-with-interrupts (with-interrupts ...))

Care must be taken not to let either ALLOW-WITH-INTERRUPTS or
WITH-LOCAL-INTERRUPTS appear in a function that escapes from inside the
WITHOUT-INTERRUPTS in:

  (without-interrupts
    ;; The body of the lambda would be executed with WITH-INTERRUPTS allowed
    ;; regardless of the interrupt policy in effect when it is called.
    (lambda () (allow-with-interrupts ...)))

  (without-interrupts
    ;; The body of the lambda would be executed with interrupts enabled
    ;; regardless of the interrupt policy in effect when it is called.
    (lambda () (with-local-interrupts ...)))
"
WRITE
#'"Function in COMMON-LISP package:
Syntax: (OBJECT &KEY (STREAM *STANDARD-OUTPUT*) (ESCAPE *PRINT-ESCAPE*) (RADIX *PRINT-RADIX*) (BASE *PRINT-BASE*) (CIRCLE *PRINT-CIRCLE*) (PRETTY *PRINT-PRETTY*) (LEVEL *PRINT-LEVEL*) (LENGTH *PRINT-LENGTH*) (CASE *PRINT-CASE*) (ARRAY *PRINT-ARRAY*) (GENSYM *PRINT-GENSYM*))

Prints OBJECT in the specified mode.  See the variable docs of *PRINT-...* for
the mode.
"
WRITE-BYTE
#'"Function in COMMON-LISP package:
Syntax: (INTEGER STREAM)

Outputs INTEGER to the binary stream STREAM.  Returns INTEGER.
"
WRITE-CHAR
#'"Function in COMMON-LISP package:
Syntax: (CHAR &OPTIONAL (STREAM *STANDARD-OUTPUT*))

Outputs CHAR to STREAM.  Returns CHAR.
"
WRITE-LINE
#'"Function in COMMON-LISP package:
Syntax: (STRING &OPTIONAL (STREAM *STANDARD-OUTPUT*) &KEY (START 0) (END (LENGTH STRING)))

Outputs STRING and a newline character to STREAM.  Returns STRING.
"
WRITE-STRING
#'"Function in COMMON-LISP package:
Syntax: (STRING &OPTIONAL (STREAM *STANDARD-OUTPUT*) &KEY (START 0) (END (LENGTH STRING)))

Outputs STRING to STREAM.  Returns STRING.
"
WRITE-TO-STRING
#'"Args: (object &key (escape *print-escape*) (radix *print-radix*)
                   (base *print-base*) (circle *print-circle*)
                   (pretty *print-pretty*) (level *print-level*)
                   (length *print-length*) (case *print-case*)
                   (array *print-array*) (gensym *print-gensym*))
Returns as a string the printed representation of OBJECT in the specified
mode.  See the variable docs of *PRINT-...* for the mode."
Y-OR-N-P
#'"Args: (&optional format-string &rest args)
Asks the user a Y-or-N question.  Does FRESH-LINE, prints a message as if
FORMAT-STRING and ARGs were given to FORMAT, and then prints \"(Y or N)\" is
printed.  If FORMAT-STRING is NIL, however, no prompt will appear."
YES-OR-NO-P
#'"Args: (&optional format-string &rest args)
Asks the user an YES-or-NO question.  Does FRESH-LINE, prints a message as if
FORMAT-STRING and ARGs were given to FORMAT, and then prints \"(Y or N)\" is
printed.  If FORMAT-STRING is NIL, however, no prompt will appear."
ZEROP
#'"Function in COMMON-LISP package:
Syntax: (NUMBER)

Returns T if the arg is zero; NIL otherwise.
"
